<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Nico随笔">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Nico随笔">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nico随笔">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title> Nico随笔 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nico随笔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/deep_link设计方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/deep_link设计方案/" itemprop="url">
                  Deeplink 设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。<br>需要前端和客户端互相配合来实现本功能。</p>
<h1 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h1><pre><code>&lt;html&gt;
&lt;head&gt;
&lt;meta property=&quot;al:ios:url&quot; content=&quot;applinks://docs&quot; /&gt;
&lt;meta property=&quot;al:ios:app_store_id&quot; content=&quot;12345&quot; /&gt;
&lt;meta property=&quot;al:ios:app_name&quot; content=&quot;App Links&quot; /&gt;
&lt;meta property=&quot;al:android:url&quot; content=&quot;applinks://docs&quot; /&gt;
&lt;meta property=&quot;al:android:app_name&quot; content=&quot;App Links&quot; /&gt;
&lt;meta property=&quot;al:android:package&quot; content=&quot;org.applinks&quot; /&gt;
&lt;meta property=&quot;al:web:url&quot;
content=&quot;http://applinks.org/documentation&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
Hello, world!
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 </p>
<ol>
<li>需要先在menifest中注册相应的scheme的filter。<br>ps:一般加载主页上面.</li>
</ol>
<pre><code>&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;
&lt;!-- Accepts URIs that begin with &quot;tsrj://&quot; --&gt;
&lt;data android:scheme=&quot;tsrj&quot;/&gt;
&lt;/intent-filter&gt;
&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;
&lt;!-- Accepts URIs that begin with &quot;http://m.tsrj.com/&quot; --&gt;
&lt;data
android:host=&quot;m.tsrj.com&quot;
android:pathPrefix=&quot;/&quot;
android:scheme=&quot;http&quot;/&gt;
&lt;data
android:host=&quot;m.tsrj.com&quot;
android:pathPrefix=&quot;/&quot;
android:scheme=&quot;https&quot;/&gt;
&lt;/intent-filter&gt;
</code></pre><ol>
<li>在MainActivity新增解析jump信息的方法</li>
</ol>
<pre><code>private void jump(Intent intent) {
/** 根据传过来的参数 进行jump跳转 **/
String action_url = intent.getDataString();
MLog.i(&quot;启动Main_action_url:&quot; + action_url);
if (!TextUtils.isEmpty(action_url)) {
JumpManager.jump(this, action_url);
} 
}

JumpManger就实现解析数据然后根据URI跳转的功能
public static boolean jump(Context ctx, String action_url) {

if (TextUtils.isEmpty(action_url)) {
return false;
}

MLog.d(&quot;JumpManager  url:&quot; + action_url);

Uri uri = null;

/**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/

try {
uri = Uri.parse(action_url);
} catch (Exception e) {
return false;
}

if (uri == null) {
return false;
}

/**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/

if (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {

return false;
}

Intent jumpintent = null;

List&lt;String&gt; paths = uri.getPathSegments();

/**只有头没有页面参数就返回*/
if (paths == null || paths.size() &lt;= 0) {

return false;
}

/**有path 但是path里面为空值 直接打开*/
String action = paths.get(0);
if (TextUtils.isEmpty(action)) {
if (!isFromWebView) {
jumpToInteriorPageActivity(ctx, uri);
}
return false;
}

/** 使用系统浏览器打开 */
if (action.equals(&quot;web_system&quot;)) {
jumpToSystemWebPage(ctx, uri);
return true;
}


/*else if (action.equals(JumpPageSet.detail)) {
goWaitress(ctx, action_url);
return true;
}*/

/** city */
else if (action.equals(JumpPageSet.city)) {
goCity(ctx, action_url);
return true;
}

/** usercenter */
else if (action.equals(JumpPageSet.personal_info)) {
goUserCenter(ctx, action_url);
return true;
}
</code></pre><ol>
<li>处理uri解析出里面的参数,放入intent，并跳往相应的主页</li>
</ol>
<pre><code>/**
 * 将url的数据进行解析 得到一个存放所有参数的集合
 */
public static Set&lt;String&gt; getMyQueryParameterNames(Uri uri) {
    String query = uri.getEncodedQuery();
    if (query == null) {
        return Collections.emptySet();
    }
    Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;();
    int start = 0;
    do {
        int next = query.indexOf(&apos;&amp;&apos;, start);
        int end = (next == -1) ? query.length() : next;
        int separator = query.indexOf(&apos;=&apos;, start);
        if (separator &gt; end || separator == -1) {
            separator = end;
        }
        String name = query.substring(start, separator);
        names.add(Uri.decode(name));
        // Move start to end of name.
        start = end + 1;
    } while (start &lt; query.length());
    return Collections.unmodifiableSet(names);
}
private static void goWaitress(final Context ctx, String actionUrl) {
    MLog.i(&quot;actionUrl&quot;+actionUrl);
    Uri  uri;
    uri=Uri.parse(actionUrl);
    Set&lt;String&gt;  parameters=JumpManager.getMyQueryParameterNames(uri);
    Hashtable&lt;String,String&gt; params=new Hashtable&lt;&gt;();
    if(parameters!=null&amp;&amp;parameters.size()&gt;0){
        for(String key:parameters){
            String value=uri.getQueryParameter(key);
            if(!TextUtils.isEmpty(value)){
                params.put(key,value);
            }
        }
    }
    Intent it= new Intent(act, WaitressPage.class);
    Set&lt;String&gt;  keySet=params.keySet();
    for (String k:keySet){
        it.putExtra(k,params.get(k));
    }
    startActivity(it);
    }
</code></pre><h1 id="DeepLink的坑："><a href="#DeepLink的坑：" class="headerlink" title="DeepLink的坑："></a>DeepLink的坑：</h1><ol>
<li>由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开</li>
<li>如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作</li>
</ol>
<p>#微信里面的deeplink：<br>微信里面的主要就是二维码加上linkme，linkme和微信有合作可以直接把分享的内容通过里面的二维码倒回到app，不过这里要注意一个问题<br>微信里面的图片对size 是有要求的</p>
<p>图片size越大被压的越厉害，，这个即使通过以下方式绕过微信sdk也无法避免被压缩</p>
<pre><code>try {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setAction(Intent.ACTION_VIEW);
    intent.addCategory(Intent.CATEGORY_DEFAULT);
    ComponentName cmp = new ComponentName(&quot;com.tencent.mm&quot;, &quot;com.tencent.mm.ui.tools.ShareScreenImgUI&quot;);
    intent.setComponent(cmp);
    String path = localImgPath;
    if (!TextUtils.isEmpty(path) &amp;&amp; !path.startsWith(&quot;file://&quot;)) {
        path = &quot;file://&quot; + path;
    }
    intent.setDataAndType(Uri.parse(path), &quot;image/jpeg&quot;);
    act.startActivity(intent);
} catch (Exception e) {
    ELog.e(&quot;wechat share failed&quot;);
}
</code></pre><p> 所以只有自己先压缩图片到一定的size，  再在这张压缩过的图片上绘制真正的二维码才行，（如果遇到好心的UI把二维码设计的很大就，可以跳过这个坑）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/动态往apk写入信息/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/动态往apk写入信息/" itemprop="url">
                  快速打包方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android快速打包/" itemprop="url" rel="index">
                    <span itemprop="name">Android快速打包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="往apk文件里面动态添加信息的两种方法。"><a href="#往apk文件里面动态添加信息的两种方法。" class="headerlink" title="往apk文件里面动态添加信息的两种方法。"></a>往apk文件里面动态添加信息的两种方法。</h1><p>（都需要保留安装时候的apk文件）</p>
<ol>
<li>方案一：往meta_info里面添加文件,写入参数信息</li>
<li>方案二：在apk这个文件的comment信息里面添加需要传入的信息  </li>
</ol>
<h2 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h2><p>参考：<a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">http://tech.meituan.com/mt-apk-packaging.html</a><br>主要代表：美团<br>原理：meta_info（里面存的就是签名信息）里面的文件不参与签名，修改后，apk不需要签名 </p>
<h2 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h2><p>参考：<a href="http://blog.csdn.net/kongpinde/article/details/51518466" target="_blank" rel="external">http://blog.csdn.net/kongpinde/article/details/51518466</a><br>主要代表：天猫、豌豆荚<br>原理：apk就是一个zip压缩包。而zip包有个comment区域，可以往里面写入信息，而不对apk的安装产生影响<br>zip 文件的末尾有一个 Central Directory Record 区域，其末尾包含一个 File comment 区域，可以存放一些数据，所以 File comment 是 zip 文件一部分，如果可以正确的修改这个部分，就可以在不破坏压缩包、不用重新打包的的前提下快速的给 Apk 文件写入自己想要的数据。</p>
<p>comment 是在 Central Directory Record 末尾储存的，可以将数据直接写在这里，下表是 header 末尾的结构。<br> <img src="https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment.png" alt="image"><br>从表中可以看到定义 comment 长度的字段位于 comment 之前。</p>
<p>这里我们需要自定义 comment，在自定义 comment 内容的后面添加一个区域储存 comment 的长度，结构如下图。<br><img src="https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/zip_comment_structure.png" alt="image"></p>
<h3 id="Server动态生成apk"><a href="#Server动态生成apk" class="headerlink" title="Server动态生成apk"></a>Server动态生成apk</h3><p>这一部分可以在本地或服务端进行，需要定义一个长度为 2 的 byte[] 来储存 comment 的长度，直接使用 Java 的 api 就可以把 comment 和 comment 的长度写到 Apk 的末尾，代码如下：</p>
<pre><code>public static void writeApk(File file, String comment) {
    ZipFile zipFile = null;
    ByteArrayOutputStream outputStream = null;
    RandomAccessFile accessFile = null;
    try {
        zipFile = new ZipFile(file);
        String zipComment = zipFile.getComment();
        // 判断comment区域是否已经有数据了
        if (zipComment != null)
            return;
        byte[] byteComment = comment.getBytes();
        outputStream = new ByteArrayOutputStream();
        // 将数据写入输出流
        outputStream.write(byteComment);
        // 紧接着写入数据大小
        outputStream.write(short2Stream((short) byteComment.length));
            byte[] data = outputStream.toByteArray();
        accessFile = new RandomAccessFile(file, &quot;rw&quot;);
        // 跳到comment区域
        accessFile.seek(file.length() - 2);
        // 先写入数据大小
        accessFile.write(short2Stream((short) data.length));
        // 写入数据
        accessFile.write(data);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (zipFile != null)
                zipFile.close();
            if (outputStream != null)
                outputStream.close();
            if (accessFile != null)
                accessFile.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
private static byte[] short2Stream(short data) {
    ByteBuffer buffer = ByteBuffer.allocate(2);
    buffer.order(ByteOrder.LITTLE_ENDIAN);
    buffer.putShort(data);
    buffer.flip();
    return buffer.array();
}
</code></pre><h3 id="客户端解析apk数据："><a href="#客户端解析apk数据：" class="headerlink" title="客户端解析apk数据："></a>客户端解析apk数据：</h3><pre><code>private static String readApk(Context context) {
    // 获取文件路径
    File file = new File(context.getPackageCodePath());
    byte[] bytes = null;
    RandomAccessFile accessFile = null;
    try {
        accessFile = new RandomAccessFile(file, &quot;r&quot;);
        long index = accessFile.length();
        bytes = new byte[2];
        // 获取comment文件的位置
        index = index - bytes.length;
        accessFile.seek(index);
        // 获取comment中写入数据的大小byte类型
        accessFile.readFully(bytes);
        // 将byte转换成大小
        int contentLength = stream2Short(bytes, 0);
        // 创建byte[]数据大小来存储写入的数据
        bytes = new byte[contentLength];
        index = index - bytes.length;
        accessFile.seek(index);
        // 读取数据
        accessFile.readFully(bytes);
        return new String(bytes, &quot;utf-8&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        if (accessFile != null) {
            try {
                accessFile.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    return null;
}


private static short stream2Short(byte[] stream, int offset) {
    ByteBuffer buffer = ByteBuffer.allocate(2);
    buffer.order(ByteOrder.LITTLE_ENDIAN);
    buffer.put(stream[offset]);
    buffer.put(stream[offset + 1]);
    return buffer.getShort(0);
}
</code></pre><h1 id="apk的安装过程"><a href="#apk的安装过程" class="headerlink" title="apk的安装过程"></a>apk的安装过程</h1><ol>
<li>复制APK安装包到data/app目录下（所以安装完成后，即使把sd卡中的apk删除也没关系）;</li>
<li>解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录;</li>
<li>并data/data目录下创建对应的应用数据目录。</li>
</ol>
<h2 id="应用安装涉及到如下几个目录："><a href="#应用安装涉及到如下几个目录：" class="headerlink" title="应用安装涉及到如下几个目录："></a>应用安装涉及到如下几个目录：</h2><p>system/app —————系统自带的应用程序，获得adb root权限才能删除</p>
<p>data/app  —————用户程序安装的目录。安装时把                                                                                                      apk文件复制到此目录<br>data/data —————存放应用程序的数据<br>data/dalvik-cache——–将apk中的dex文件安装到dalvik-cache目录下(dex文件是dalvik虚拟机的可执行文件,其大小约为原始apk文件大小的四分之一)</p>
<h2 id="app卸载"><a href="#app卸载" class="headerlink" title="app卸载"></a>app卸载</h2><p>删除安装过程中在上述三个目录下创建的文件及目录。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/Okhttp核心流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/Okhttp核心流程/" itemprop="url">
                  Okhttp核心流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Interface：OkhttpClient（singleton）-Request-Response"><a href="#Interface：OkhttpClient（singleton）-Request-Response" class="headerlink" title="Interface：OkhttpClient（singleton）  Request  Response"></a>Interface：OkhttpClient（singleton）  Request  Response</h2><h2 id="主要由以下三部分-组成"><a href="#主要由以下三部分-组成" class="headerlink" title="主要由以下三部分 组成"></a>主要由以下三部分 组成</h2><h3 id="1-任务调度：-核心类disruptor（singleton）"><a href="#1-任务调度：-核心类disruptor（singleton）" class="headerlink" title="1. 任务调度： 核心类disruptor（singleton）"></a>1. 任务调度： 核心类disruptor（singleton）</h3><p>a. 线程池<br>b. 队列</p>
<pre><code>/** Ready async calls in the order they&apos;ll be run. */
private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();

/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */
private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();

/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */
 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();
</code></pre><p>(由于okhttp两种 运行模式   sync  和async）</p>
<h3 id="2-网络请求"><a href="#2-网络请求" class="headerlink" title="2. 网络请求"></a>2. 网络请求</h3><ul>
<li>核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） </li>
<li>每个请求会生成一个Request  </li>
<li>然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  </li>
</ul>
<p>okhttp一个请求的完整流程图<br> <img src="http://blog.piasy.com/img/201607/okhttp_full_process.png" alt="image"></p>
<p>在realcall的execute方法中会调用     </p>
<pre><code>client.dispatcher().executed(this);//问题1  
Response result = getResponseWithInterceptorChain(false);//问题2  
</code></pre><p>获得请求结果.<br>现在看问题1  在这里面干了写什么<br>其实就是 dispatcher记录任务而已 ，没有任何执行方法<br>核心在问题2中<br>她会  </p>
<pre><code>Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
return chain.proceed(originalRequest);
</code></pre><p>也就是生成拦截器 ，并用这个拦截器启动这个请求<br>继续进入proceed 可以看到<br>进入了ApplicationInterceptorChain的getresponse方法<br>开始构造HttpEngine    </p>
<pre><code>engine.sendRequest();//问题21
engine.readResponse();//问题22
</code></pre><p>在问题21中其实就是  Rfc 标准的一种 实现  </p>
<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);
Response cacheCandidate = responseCache != null
    ? responseCache.get(request)
    : null;
</code></pre><p>就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache<br>这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程<br>当取到值后还要根据http cache的rfc标准  判断  是否合理能使用<br>new CacheStrategy.Factory(now, request, cacheCandidate).get();<br>在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  </p>
<p>这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）</p>
<pre><code>if (etag != null) {
  conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);
} else if (lastModified != null) {
  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);
} else if (servedDate != null) {
  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);
}

Request conditionalRequest = conditionalRequestBuilder.build();
</code></pre><p>这是请求前的工作<br>现在开始发送请求</p>
<pre><code>httpStream = connect();
httpStream.setHttpEngine(this);
</code></pre><p>这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）</p>
<pre><code>streamAllocation.newStream(client.connectTimeoutMillis(),
client.readTimeoutMillis(), client.writeTimeoutMillis(),
client.retryOnConnectionFailure(), doExtensiveHealthChecks);
</code></pre><p>解决的问题 是socket连接重用和  route<br>先是从连接池中找</p>
<pre><code>// Attempt to get a connection from the pool.
 RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
 if (pooledConnection != null) {
   this.connection = pooledConnection;
   return pooledConnection;
 }
</code></pre><p>如果没有的话就看route可以重用嘛</p>
<pre><code> if (selectedRoute == null) {
  selectedRoute = routeSelector.next();
  synchronized (connectionPool) {
    route = selectedRoute;
  }
}
RealConnection newConnection = new RealConnection(selectedRoute);
acquire(newConnection);
</code></pre><p>（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止</p>
<pre><code>RouteDatabase里的Set&lt;Route&gt; failedRoutes = new LinkedHashSet&lt;&gt;()）
</code></pre><p>弄完之后就是放如   </p>
<pre><code>Internal.instance.put(connectionPool, newConnection);
</code></pre><p>连接池中  方便下次继续使用<br>下一步 就是建立socket连接的过程</p>
<pre><code> newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
    connectionRetryEnabled);
routeDatabase().connected(newConnection.route());
</code></pre><p>跟进去 就是</p>
<pre><code>connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
</code></pre><p>继续</p>
<pre><code> try {
  Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
} catch (ConnectException e) {
  throw new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());
}
source = Okio.buffer(Okio.source(rawSocket));
sink = Okio.buffer(Okio.sink(rawSocket));
</code></pre><p>连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的<br>然后才是真正发送这个请求的过程</p>
<pre><code>httpStream.writeRequestHeaders(networkRequest);
requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
</code></pre><p>继续跟进</p>
<pre><code> httpEngine.writingRequestHeaders();
  String requestLine = RequestLine.get(
    request, httpEngine.getConnection().route().proxy().type());
writeRequest(request.headers(), requestLine);
</code></pre><p>》》</p>
<pre><code>** Returns bytes of a request header for sending on an HTTP transport. */
public void writeRequest(Headers headers, String requestLine) throws IOException {
if (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);
sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;);
for (int i = 0, size = headers.size(); i &lt; size; i++) {
  sink.writeUtf8(headers.name(i))
      .writeUtf8(&quot;: &quot;)
      .writeUtf8(headers.value(i))
      .writeUtf8(&quot;\r\n&quot;);
}
sink.writeUtf8(&quot;\r\n&quot;);
state = STATE_OPEN_REQUEST_BODY;
}
</code></pre><p>读过程<br>就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink</p>
<p>到此 请求reponse的工作做完了<br>现在 如果是需要真正发送网络请求就也就是问题22</p>
<pre><code>networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
</code></pre><p>》》</p>
<pre><code>engin.readResponse
</code></pre><p>》》</p>
<pre><code>// Write the request body to the socket.
if (requestBodyOut != null) {
  if (bufferedRequestBody != null) {
    // This also closes the wrapped requestBodyOut.
    bufferedRequestBody.close();
  } else {
    requestBodyOut.close();
  }
  if (requestBodyOut instanceof RetryableSink) {
    httpStream.writeRequestBody((RetryableSink) requestBodyOut);
  }
}

networkResponse = readNetworkResponse();
</code></pre><p>》》</p>
<pre><code>Response readNetworkResponse() throws IOException {
httpStream.finishRequest();

Response networkResponse = httpStream.readResponseHeaders()
    .request(networkRequest)
    .handshake(streamAllocation.connection().handshake())
    .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
    .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
    .build();

if (!forWebSocket) {
  networkResponse = networkResponse.newBuilder()
      .body(httpStream.openResponseBody(networkResponse))
      .build();
}

if (&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;))
    || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) {
  streamAllocation.noNewStreams();
}

return networkResponse;
</code></pre><p>  }</p>
<p>解析和返回</p>
<pre><code> Response response = engine.getResponse();


//tobe continue（已经 cache过程 请求重试过程）
 Request followUp = engine.followUpRequest();
</code></pre><h3 id="3-cache管理"><a href="#3-cache管理" class="headerlink" title="3. cache管理"></a>3. cache管理</h3><p>最后附上 相关的http请求cache的rfc内容<br> <img src="https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg" alt="image"></p>
<h3 id="每个状态的详细说明如下："><a href="#每个状态的详细说明如下：" class="headerlink" title="每个状态的详细说明如下："></a>每个状态的详细说明如下：</h3><h4 id="1-Last-Modified"><a href="#1-Last-Modified" class="headerlink" title="1. Last-Modified"></a>1. Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：<br>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT<br>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  </p>
<h4 id="2-Etag工作原理"><a href="#2-Etag工作原理" class="headerlink" title="2. Etag工作原理"></a>2. Etag工作原理</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<br>Etag:“5d8c72a5edda8d6a:3239″<br>客户端的查询更新格式是这样的：<br>If-None-Match:“5d8c72a5edda8d6a:3239″<br>如果ETag没改变，则返回状态304。<br>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″<br>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。<br>If-None-Match:“5d8c72a5edda8d6a:3239“<br>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  </p>
<h4 id="3-Expires"><a href="#3-Expires" class="headerlink" title="3. Expires"></a>3. Expires</h4><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT<br>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  </p>
<h4 id="4-Last-Modified和Expires"><a href="#4-Last-Modified和Expires" class="headerlink" title="4. Last-Modified和Expires"></a>4. Last-Modified和Expires</h4><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  </p>
<h4 id="5-Etag和Expires"><a href="#5-Etag和Expires" class="headerlink" title="5. Etag和Expires"></a>5. Etag和Expires</h4><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  </p>
<h4 id="6-Last-Modified和Etag"><a href="#6-Last-Modified和Etag" class="headerlink" title="6. Last-Modified和Etag"></a>6. Last-Modified和Etag</h4><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)<br>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存<br>过程如下:  </p>
<ul>
<li>客户端请求一个页面（A）。  </li>
<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。  </li>
<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  </li>
<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  </li>
<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  </li>
</ul>
<p>备注：   </p>
<ul>
<li>Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  </li>
<li>WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  </li>
<li>客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  </li>
<li>通过上述值到服务器端检查，判断文件是否继续缓存；  </li>
</ul>
<h4 id="7-关于-Cache-Control-max-age-秒-和-Expires"><a href="#7-关于-Cache-Control-max-age-秒-和-Expires" class="headerlink" title="7.关于 Cache-Control: max-age=秒 和 Expires"></a>7.关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。<br>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。<br>Expires =max-age +   “每次下载时的当前的request时间”<br>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/gradle坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/gradle坑/" itemprop="url">
                  AS 踩坑日记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>升级instant run时候的报错<br>Error:Access to the dex task is now impossible, starting with 1.4.0<br>1.4.0 introduces a new Transform API allowing manipulation of the .class files.<br>See more information: <a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="external">http://tools.android.com/tech-docs/new-build-system/transform-api</a></p>
<p>解决方案：</p>
<p>buildscript {<br>    repositories {<br>        jcenter()<br>    }<br>    dependencies {<br>        classpath ‘com.android.tools.build:gradle:2.0.0’</p>
<pre><code>}
</code></pre><p>}</p>
<p>改成1.3.0</p>
<p>项目根目录的gradle的<br>grade.property</p>
<p>distributionUrl=https\://services.gradle.org/distributions/gradle-2.2-all.zip</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/混淆写法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/混淆写法/" itemprop="url">
                  混淆写法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/打包/" itemprop="url" rel="index">
                    <span itemprop="name">打包</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>-keepclassmembers class <strong> {<br>    public void onEvent*(</strong>);<br>}</p>
<p>只保护 public void onEvent<em>(*</em>)的方法不被重命名</p>
<p>-keepattributes Signature</p>
<p>-keep class okio.<em>* {</em>;}</p>
<p>-keep class android.support.v4.app.NotificationCompat<em>*{<br>    public </em>;<br>}</p>
<p>-keep class com.veda.lyc.Utils{ static *;}<br>保持里面的静态方法不被混淆</p>
<p>keep的几个选项</p>
<table>
<thead>
<tr>
<th>Keep</th>
<th style="text-align:right">From being removed or renamed</th>
<th style="text-align:center">From being renamed</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classes and class members</td>
<td style="text-align:right">-keep</td>
<td style="text-align:center">-keepnames</td>
</tr>
<tr>
<td>Class members only</td>
<td style="text-align:right">-keepclassmembers</td>
<td style="text-align:center">-keepclassmembernames</td>
</tr>
<tr>
<td>-keepclassmembers    -keepclassmembernames</td>
</tr>
</tbody>
</table>
<p>Classes and class members, if class members present       |    -keepclasseswithmembers    |  -keepclasseswithmembernames  |</p>
<p>参考资料<br><a href="http://blog.csdn.net/sudic_niu/article/details/7921548" target="_blank" rel="external">http://blog.csdn.net/sudic_niu/article/details/7921548</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/Xcode 和Android  studio 快捷键及设置对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/Xcode 和Android  studio 快捷键及设置对比/" itemprop="url">
                  AS和Xcode快捷键
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h1><p>XCode   不能直接修改文件名，需要找到本文件对应的申明或者实现的名称，右键refactor&gt;rename  修改<br>（记得勾选 Rename related files）</p>
<p>在 Xcode里面所有的窗口控制显示与否都可以通过右上角的来控制  </p>
<p>定位类的位置  shift  commoand  j</p>
<p>commond  6 </p>
<p>option 然后点击方法位置</p>
<p>commond   T</p>
<p>shift  commoand  O</p>
<p>shift  commoand  F</p>
<p> commoand  F</p>
<p>esc  查看方法参数   </p>
<p>快捷键位置方法   XCode&gt;preferences&gt;Key Bindings</p>
<p>显示主题颜色设置   XCode&gt;preferences&gt;Font &amp; Colors   从Default  改成   Dusk<br>窗口显示和隐藏的button（其中代码下面的debug和log窗口在他们的右下角又有单独的控制显示和隐藏的button）  </p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E8%AE%BE%E7%BD%AE.png?raw=true" alt="image"></p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE.jpg?raw=true" alt="image">  </p>
<p>参考资料：<a href="http://www.cocoachina.com/ios/20141224/10752.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20141224/10752.html</a></p>
<h1 id="AndroidStudio"><a href="#AndroidStudio" class="headerlink" title="AndroidStudio"></a>AndroidStudio</h1><p>快捷键位置方法   AndroidStudio&gt;preferences&gt;Keymap  （把Mac  OS X 复制一份，然后修改）</p>
<p>显示主题颜色设置   AndroidStudio&gt;preferences&gt;Editor&gt;Colors &amp; Font   从Default  改成   Darcula  (然后点击 save as  ，再把字体调大一点，不能直接修改) </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/Gradle小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/Gradle小结/" itemprop="url">
                  Gradle配置分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TopicLevel的gradle    </p>
<pre><code>buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}
allprojects {
    repositories {
        jcenter()
    }
}
task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><p>Mudule level的build.gradle  </p>
<pre><code>apply plugin: &apos;com.android.application&apos;

android {
    compileSdkVersion 20
    buildToolsVersion &quot;24.0.0&quot;


    compileOptions{
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    defaultConfig {
        applicationId &quot;com.lyc.study&quot;
        minSdkVersion 15
        targetSdkVersion 20
        versionCode 1
        versionName &quot;1.0&quot;
        jackOptions{
            enabled true
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
}

dependencies {
    compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)
    compile &apos;com.android.support:support-v4:+&apos;
    compile &apos;com.android.support:support-annotations:22.2.0&apos;
    compile &apos;com.android.support:support-v13:20.1.1&apos;
}
</code></pre><p>以上是标准的打包方式,下面是常用的我们自定义的内容   </p>
<pre><code>dependencies {
    compile fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)
    compile project(&apos;:google_services&apos;)

    // compile &apos;com.android.support:multidex:1.0.1&apos;
    compile &apos;top.zibin:Luban:1.0.9&apos;
    debugCompile &apos;com.bugtags.library:bugtags-lib:latest.integration&apos;

    testCompile &apos;junit:junit:4.12&apos;

}

android {
    compileSdkVersion 21
    buildToolsVersion &apos;23.0.2&apos;

    sourceSets {
        main {
            manifest.srcFile &apos;AndroidManifest.xml&apos;
            java.srcDirs = [&apos;src&apos;]
            resources.srcDirs = [&apos;src&apos;]
            aidl.srcDirs = [&apos;src&apos;]
            renderscript.srcDirs = [&apos;src&apos;]
            res.srcDirs = [&apos;res&apos;]
            assets.srcDirs = [&apos;assets&apos;]
            jniLibs.srcDirs = [&apos;libs&apos;]
        }

        test.setRoot(&apos;test&apos;)

        debug.setRoot(&apos;build-types/debug&apos;)
        release.setRoot(&apos;build-types/release&apos;)
    }

    signingConfigs {
        debug {
            // 请配置好pub.key及其密码，或者改为使用debug.keystore
            storeFile file(&apos;pub.key&apos;) // storeFile file(&apos;debug.keystore&apos;)
            storePassword STORE_PASSWORD
            keyAlias KEY_ALIAS
            keyPassword KEY_PASSWORD
        }
        release {
            storeFile file(&apos;pub.key&apos;)
            storePassword STORE_PASSWORD
            keyAlias KEY_ALIAS
            keyPassword KEY_PASSWORD
        }
    }

    buildTypes {
        debug {
            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\&quot;Not yet\&quot;&quot;
            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;
            signingConfig signingConfigs.debug

            ndk{
                abiFilters &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;x86&apos; //,&apos;arm64-v8a&apos;, &apos;x86_64&apos;, &apos;mips&apos;, &apos;mips64&apos;
            }
        }
        release {
            buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\&quot;2017/1/1\&quot;&quot; //  发布时修改为当天日期
            buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;false&quot; // 关闭开发者模式
            proguardFiles &apos;proguard.cfg&apos;
            minifyEnabled true
            shrinkResources true
            debuggable false
            jniDebuggable false
            signingConfig signingConfigs.release

            applicationVariants.all { variant -&gt;
                variant.outputs.each { output -&gt;
                    def outputFile = output.outputFile
                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) {
                        // APK命名格式 Going-release.apk TODO 发布时使用
                        def fileName = &quot;Going-v${defaultConfig.versionName}-${defaultConfig.versionCode}-release.apk&quot;
//                         def fileName = &quot;Going.apk&quot;
                        output.outputFile = new File(outputFile.parent, fileName)
                    }
                }
            }
        }
    }

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 22  // 请勿随意改动 //Android 6.0系统默认为targetSdkVersion小于23的应用默认授予了所申请的所有权限
        versionCode 1000
        versionName &quot;1.0.0&quot;
        //manifestPlaceholders = [ UMENG_CHANNEL_VALUE:&quot;googleMarket&quot; ]
        multiDexEnabled false
        multiDexKeepProguard file(&apos;multiDexKeep.pro&apos;)
        resConfigs &quot;en&quot;, &quot;zh_CN&quot;, &quot;zh_TW&quot; //暂时限定语言, 当前情况下缩小大概 0.2M TODO googlePlay 版本取消限制
    }

    productFlavors {
          own {}
          googleMarket {}

          tencent {}
          baidu {}


    }

//    productFlavors.all { flavor -&gt;
//        flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ]
//    }

    packagingOptions {
        exclude &apos;META-INF/LICENSE.txt&apos;
    }

    // 可以适当的打开Lint，检查是否存在隐藏问题
    lintOptions {
        checkReleaseBuilds false
        abortOnError false
    }

    android.dexOptions {
        jumboMode = true
        javaMaxHeapSize &quot;2g&quot;
        maxProcessCount 8
    }

}

// 替换编码方式，否则编译可能有中文乱码
tasks.withType(org.gradle.api.tasks.compile.JavaCompile) {
    options.encoding = &quot;UTF-8&quot;
}
</code></pre><p>相对于标准的我们在 android Task中新增了sourceSets这个Task制定了一些文件夹的目录，如果工程目录是标注的就不需要设置了</p>
<p>在build.gradle同级新建一个gradle.properties<br>里面可以用来存放build.gradle里面的一些参数<br>STORE_PASSWORD=nico<br>KEY_ALIAS=nick<br>KEY_PASSWORD=nico</p>
<p>这个地方对应的脚本是signingConfigs》debug里面的参数 </p>
<p> buildTypes 》debug 中的buildConfigField参数则会在编译时候  </p>
<p> <img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/gradle%E5%88%86%E6%9E%9001.png?raw=true" alt="gradle01"></p>
<pre><code>buildConfigField &quot;String&quot;, &quot;RELEASE_TIME&quot;, &quot;\&quot;Not yet\&quot;&quot;
buildConfigField &quot;boolean&quot;, &quot;DEVELOP_MODE&quot;, &quot;true&quot;
</code></pre><p>会在编译时候生成并存放在build/generated/source/buildConfig/…BuildConfig.java   </p>
<pre><code>public final class BuildConfig {
  public static final boolean DEBUG = Boolean.parseBoolean(&quot;true&quot;);
  public static final String APPLICATION_ID = &quot;com.lyc.study&quot;;
  public static final String BUILD_TYPE = &quot;debug&quot;;
  public static final String FLAVOR = &quot;own&quot;;
  public static final int VERSION_CODE = 100;
  public static final String VERSION_NAME = &quot;1.0.0&quot;;
  // Fields from build type: debug
  public static final boolean DEVELOP_MODE = true;
  public static final String RELEASE_TIME = &quot;Not yet&quot;;
}
</code></pre><p>可以参考友盟的多渠道打包（github）</p>
<p>一个介绍gradle比较好的网站<br><a href="http://stormzhang.com/posts/" target="_blank" rel="external">http://stormzhang.com/posts/</a></p>
<p><a href="https://segmentfault.com/a/1190000006915937" target="_blank" rel="external">https://segmentfault.com/a/1190000006915937</a></p>
<p>这两个网站都是一系列的教程，建议一个一个的看</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/Android模块化方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/Android模块化方案/" itemprop="url">
                  Android模块化方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AAR模块化方案"><a href="#AAR模块化方案" class="headerlink" title="AAR模块化方案"></a>AAR模块化方案</h2><p>1、首先 按照应用分层（common  view），注意每个module最好配置一下resourcePrefix “mc_”<br>2、上层再按照功能模块比如  信用卡和个人中心</p>
<p>这样每个都会打出一个aar，府工程引入所有的aar就可以引入这个模块</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>但是这个距离一个可以发布出去的aar还有距离，有以下几个问题需要解决：  </p>
<ol>
<li>本地jar依赖（主工程很有可能也公用这个jar）；  </li>
<li>混淆的问题；  </li>
<li>多个aar合并；   </li>
<li>兄弟模块互相调用，基模块调用父模块的方法；</li>
</ol>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1:"></a>问题1:</h3><p>Android dependency的几种方法：<br>eg：  </p>
<pre><code>    testCompile &apos;junit:junit:4.12&apos;
//compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])  
provided fileTree(dir: &apos;libs&apos;,include: [&apos;*.jar&apos;])  
compile &apos;com.android.support:support-v4:23.0.1&apos;  
compile project(&apos;:Module_common&apos;)   
</code></pre><ul>
<li>testCompile ：  debug 会编译  正式打包不会编译</li>
<li>compile ： 除去”compile jar”会编译进arr，其余的都不会编译进去</li>
<li>provided：编译时候不会把jar编译进去</li>
</ul>
<p>传递依赖的问题<br>（例如 modle A 依赖 Module B，Module B 又依赖Module  C ）   jar  都放在C里面，Module A不引入jar 也能引用到jar。</p>
<p>但是正式打包时候不需要这些jar，本地的jar必须以provided方式引入，这样aar里面就不会打进去这些jar了。</p>
<p>这会引入另外一个问题：C改成provide 这些jar后，A和B找不到这些依赖的jar 会编译失败</p>
<p>解决方案：<br>把jar单独成一个module D，写成provided<br>（也可在module A  和 B里面  把这些jar 都拷贝进去，然后统统写成provided）</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>首先要明白，我们要去混淆的是A和主工程的接口，而A和B以及C直接的调用都需要混淆，但是不能在B和C里面混淆，因为这样一混淆的话，A与B、C调用的接口也混淆了</p>
<p>所以混淆只能在A里面打开，A和B都不能打开混淆</p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>默认会打出三个aar，但是我们只能发布一个aar出去，所以必须使用到 <a href="https://github.com/adwiv/android-fat-aar" target="_blank" rel="external">https://github.com/adwiv/android-fat-aar</a> 写的合并aar的gradle</p>
<p>方法：<br>1、拷贝 fat-aar.gradle到build.gradle 同级目录<br>2、module的build.gradle新增<br>apply from: ‘fat-aar.gradle’  ，</p>
<p>compile project(‘:Module_common’)<br>改成<br>embedded project(‘:Module_common’)</p>
<p>这样在打B的aar时候，会把基moduel的aar合并进来</p>
<p>如果这个模块工程就一个工程，就只需要解决问题1，同时配置一下混淆就行</p>
<h2 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h2><p>通过hook调用<br>基模块：</p>
<pre><code>public class CommonModuleDataEngine {

    private static CommonModuleDataEngine INSTANCE;

    private AppInfo appInfo;//这个必须要父模块或者兄弟模块
    public static CommonModuleDataEngine getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new CommonModuleDataEngine();
        }
        return INSTANCE;
    }

    private CommonModuleDataEngine() {
    }

    public String getAppInfo() {
        return appInfo.getAppInfo();
    }

    public static class Builder {
        private AppInfo appInfo;

        public Builder setAppInfo(AppInfo appInfo) {
            this.appInfo = appInfo;
            return this;
        }
        public void build() {
            CommonModuleDataEngine engin = CommonModuleDataEngine.getInstance();
            engin.appInfo = this.appInfo;

        }

    }
    public interface AppInfo {

        String getAppInfo();

    }

}
</code></pre><p>主工程  </p>
<p>在Application初始化的时候初始几个基类CommonModuleDataEngine，</p>
<p>ps：内部类的去混淆  </p>
<pre><code>    -keepclasseswithmembers  class CommonModuleDataEngine {*;}
-keepclasseswithmembers  class CommonModuleDataEngine$* {*;}
</code></pre><h3 id="其它注意事项"><a href="#其它注意事项" class="headerlink" title="其它注意事项"></a>其它注意事项</h3><p>1、主程序和Module里面的Manifest里面的一些配置同名。必须在manifest  中的相应的配置里面 添加  </p>
<pre><code>tools:replace=&quot;android:icon,theme,label&quot;
</code></pre><p>例如基module和主程序都包含了高德定位，manifest必然也有相同的配置信息</p>
<pre><code>&lt;meta-data
    tools:replace=&quot;android:value&quot;
    android:name=&quot;com.amap.api.v2.apikey&quot;
    android:value=&quot;*******&quot; /&gt;
</code></pre><p>App组件化与业务拆分: <a href="http://www.jianshu.com/p/60c1b9ddd8ab" target="_blank" rel="external">http://www.jianshu.com/p/60c1b9ddd8ab</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/AS导入工程配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/AS导入工程配置/" itemprop="url">
                  AS工程导入
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-工程导入"><a href="#1-工程导入" class="headerlink" title="1.工程导入"></a>1.工程导入</h1><h2 id="1-1-普通eclipse-工程导入"><a href="#1-1-普通eclipse-工程导入" class="headerlink" title="1.1 普通eclipse  工程导入"></a>1.1 普通eclipse  工程导入</h2><p>直接import，AS会提示转成eclipse工程</p>
<h2 id="1-2-github上的工程导入"><a href="#1-2-github上的工程导入" class="headerlink" title="1.2 github上的工程导入"></a>1.2 github上的工程导入</h2><p>用AS打开top level的settings.gradle选择进行配置导入<br>ps：如果这一步直接导入的话就会报   Could not find method android() for arguments   </p>
<p>可能遇到的问题：  </p>
<ol>
<li><p>配置sdk位置（顶层build.gradle同级）<br>local.properties（建议从已有工程拷贝一个）<br>sdk.dir=/Users/lyc/codeTools/android-sdk  </p>
</li>
<li><p>配置模块的build.gradle的gradletoolVersion版本<br>buildToolsVersion ‘23.0.2’</p>
</li>
</ol>
<p>建议从已有工程的里面找一个可用的版本填上去</p>
<p>查看自己已经有哪些版本的buildTools的方法，</p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B01.png?raw=true" alt="see">  </p>
<ol>
<li>modle配置模块的工程compileSdkVersionversion<br>为一个已有版本的</li>
</ol>
<ol>
<li>配置<br>dependencies中的com.android.support的版本，要求是于compileSdkVersionversion的版本一直<br>，但是这个不好处理</li>
</ol>
<p>compile ‘com.android.support:design:25.1.1’<br>compile ‘com.android.support:appcompat-v7:25.1.1’<br>compile ‘com.android.support:cardview-v7:25.1.1’</p>
<p>英文有子序列号<br>建议按照以下方法写<br>compile ‘com.android.support:cardview-v7:25.+’<br>这样就会取本版本号下面最大的一个</p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/AS%E5%AF%BC%E5%85%A5%E5%B7%A5%E7%A8%8B02.png?raw=true" alt="see">   </p>
<p>5.配置本地Gradel版本<br>这个常见于直接从别人那里拷贝的工程（也就是带有gradle/wrapper/**）的工程</p>
<pre><code>distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip 
</code></pre><p>gradle会去找这个版本的gradle，如果找不到就会重新下载<br>gradle的默认下载目录在用户目录的.gradle/wrapper/dists文件夹中（隐藏的）  里面会有所有已经下载的gradle 版本，可以把它改成一个已经有的版本就行</p>
<h2 id="1-3-本地工程导入"><a href="#1-3-本地工程导入" class="headerlink" title="1.3 本地工程导入"></a>1.3 本地工程导入</h2><p>直接import</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/简易java热补丁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/简易java热补丁/" itemprop="url">
                  热补丁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="核心两个部分"><a href="#核心两个部分" class="headerlink" title="核心两个部分"></a>核心两个部分</h2><h3 id="1-hook部分"><a href="#1-hook部分" class="headerlink" title="1. hook部分"></a>1. hook部分</h3><p>hook部分主要是使用反射调用补丁里面的内容</p>
<p>hook部分的本质是提供对补丁方法调用的封装（主工程无法直接实例和调用补丁的方法），每次调用都是通过反射调用，传入activity，handler，callback进去。</p>
<h3 id="2-补丁部分"><a href="#2-补丁部分" class="headerlink" title="2. 补丁部分"></a>2. 补丁部分</h3><p>补丁实际上是java代码转的dex<br>它的工作有两种：网络取数据，构造生成view</p>
<p>补丁部分构造view是通过hook部分传过来activity，然后用代码动态构造view，不涉及到任何布局文件，资源文件。  </p>
<h2 id="hook的初始化及调用过程"><a href="#hook的初始化及调用过程" class="headerlink" title="hook的初始化及调用过程"></a>hook的初始化及调用过程</h2><ol>
<li><p>初始化DexClassLoader  </p>
<pre><code>classLoader = new DexClassLoader(dexApkFilePath
            + dexName + &quot;.apk&quot;, context.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath(), null,
            context.getClassLoader().getParent());
</code></pre></li>
<li><p>load补丁相应的class  </p>
<pre><code>controllerClass = classLoader.loadClass(&quot;com.nico.Controller&quot;);
</code></pre></li>
<li><p>初始化构造函数</p>
<pre><code>controllerConstrucor = controllerClass.getConstructor(new Class[]{Context.class, String.class, boolean.class});
</code></pre></li>
<li><p>实例化补丁里面的类</p>
<pre><code>controllerInstance = controllerConstrucor.newInstance(new Object[]{mContext});
</code></pre></li>
<li><p>通过初始化的实例controllerInstance来调用里面的方法  </p>
<pre><code>Method initController = controllerClass.getDeclaredMethod(&quot;initController&quot;, new Class[]{String.class, String.class, String.class});
initController.setAccessible(true);
initController.invoke(controllerInstance, new Object[]{paramsA, paramsB, paramsC});
</code></pre></li>
</ol>
<h2 id="补丁的升级"><a href="#补丁的升级" class="headerlink" title="补丁的升级"></a>补丁的升级</h2><ol>
<li>校验是否有新的版本升级</li>
<li>把新的补丁下载到本地sd卡中去</li>
<li>解压补丁到data/data/app.pkg/app_dex目录<br>ZipManager.extNativeZipFile(mContext,<pre><code>mContext.getResources().getAssets().open(Utils.ZIP_NAME),
cachePath, dexApkFilePath, lastVersion)
</code></pre></li>
<li>重新走一遍补丁的实例化过程（从DexLoader开始）</li>
</ol>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ol>
<li>第一次安装，补丁放到asset目录下面</li>
<li>由于里面传入了activity，要注意销毁补丁里面的强引用</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>dexclassloader : 可以加载apk文件中的字节码<br>pathclassloader : 只能加载文件目录下的apk文件中的classes</p>
<h2 id="To-Be-Continue"><a href="#To-Be-Continue" class="headerlink" title="To Be Continue"></a>To Be Continue</h2><ol>
<li><p>load补丁里面的资源文件 ,通过反射调用AssetManger里面的资源文件，把ID设置上去 </p>
<pre><code>AssetManager assetManager = AssetManager.class.newInstance();  
Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);  
addAssetPath.invoke(assetManager, libPath);  
Resources superRes = super.getResources();  
mRes = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration());
</code></pre></li>
<li><p>尝试使用mvp模式，把controllor从activity里面剥离开来，让所有contollor可以被热补丁，这要处理起来（可以把整个app轻量化）</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/wwj_748/article/details/46349781" target="_blank" rel="external">http://blog.csdn.net/wwj_748/article/details/46349781</a></p>
<p><a href="http://blog.csdn.net/yuanzeyao/article/details/42390431" target="_blank" rel="external">http://blog.csdn.net/yuanzeyao/article/details/42390431</a></p>
<p><a href="http://blog.csdn.net/u010386612/article/details/51077291" target="_blank" rel="external">http://blog.csdn.net/u010386612/article/details/51077291</a></p>
<p><a href="http://blog.csdn.net/cn_foolishman/article/details/46874811" target="_blank" rel="external">http://blog.csdn.net/cn_foolishman/article/details/46874811</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true"
               alt="Liuycheng" />
          <p class="site-author-name" itemprop="name">Liuycheng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuycheng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
