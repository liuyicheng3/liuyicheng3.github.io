<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Nico随笔">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Nico随笔">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nico随笔">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> Nico随笔 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nico随笔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/全屏模式adjustadjustResize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/15/全屏模式adjustadjustResize/" itemprop="url">
                  全屏模式AdjustResize实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T00:00:00+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>使用stackoverflo 上的 AndroidBug5497Workaround</p>
<p>但是这个AndroidBug5497Workaround有个问题就是<br>A如果是最开始输入框在下面，就会出现输入法先把界面顶上去 ，然后又调整下来的过程<br>B如果在最上面就不会出现这个过程  </p>
<p>这个我们先考虑没有使用AndroidBug5497Workaround时候的情况<br>A如果是最开始输入框在下面，就会出现输入法会把整个界面顶上去<br>B如果在最上面，整个界面会看着基本不动，但是root view没有adjustResize的过程，因此导致原来alignparentBottom的元素看不到  </p>
<p>AndroidBug5497Workaround的原理是监听rootView 可视区域的变化，但是这个onGlobalLayout回调的速度明显慢于键盘弹出的速度，<br>所以在A情况下就会出现顶上去又弹回去的情况<br>（如果在这里纠结使监听可视区域变化速度 和 键盘弹出速度  完全 一直的话 ，那是不可能的）<br>而在B情况下，由于没加AndroidBug5497Workaround这个时候本身就不会有顶去来的过程，所以主体界面本身就不会有抖动情况（注意 我们监听时候改变了主体界面的高度，但是这个根本不会影响到主体界面，因为即使改变高度， android 绘制的坐标系也是从左上角开始的，所以不存在任何问题）<br>而这时候我们改变root view的size  只是会导致底部的aliparentBottom的控件上移动，上移动的速度实际上比键盘弹出的速度慢，但是最终能调整到键盘的位置，所以这里根本不会导致主题界面抖动</p>
<pre><code>mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
          public void onGlobalLayout() {
              possiblyResizeChildOfContent();
          }
      });

private void possiblyResizeChildOfContent() {
      int usableHeightNow = computeUsableHeight();
      if (usableHeightNow != usableHeightPrevious) {
          int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();
          int heightDifference = usableHeightSansKeyboard - usableHeightNow;
          if (heightDifference &gt; (usableHeightSansKeyboard/4)) {
              // keyboard probably just became visible
              frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;
          } else {
              // keyboard probably just became hidden
              frameLayoutParams.height = usableHeightSansKeyboard;
          }
          mChildOfContent.requestLayout();
          usableHeightPrevious = usableHeightNow;
      }
  }

private int computeUsableHeight() {
    Rect r = new Rect();
    mChildOfContent.getWindowVisibleDisplayFrame(r);
    return (r.bottom - r.top);
}
</code></pre><h4 id="虚拟按键"><a href="#虚拟按键" class="headerlink" title="虚拟按键"></a>虚拟按键</h4><p>注意android的虚拟按键有两种：<br>一种是N5 N6一类的固定在底部的虚拟按键  </p>
<p>一种是华为 小米mix 一类的的  可以通过手势动态控制底部虚拟按键显示还隐藏<br>这种就需要动态计算高度  </p>
<p>为了解决A问题，需要在顶部放置一个fake EditText ，点击目标EditText时候先让顶部的fakeEditText获得焦点，待键盘完全弹出来后再把焦点转移给目标EditText<br>具体方案：目标EditText监控ontouch事件，在TouchUp时候消耗掉这个事件，这样就不会触发键盘直接弹出来了，这时候，顶部的 fake EditText先获取焦点，延迟一段时间 待键盘完全弹出后再让目标EditText获取焦点</p>
<h2 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h2><p><a href="https://github.com/Jacksgong/JKeyboardPanelSwitch" target="_blank" rel="external">https://github.com/Jacksgong/JKeyboardPanelSwitch</a><br>原理：<br>在目标EditText下面加一个KPSwitchPanelLinearLayout  通过动态设置这个KPSwitchPanelLinearLayout的Visual状态和高度动态调整高度<br>其包括两个步骤<br>1、测量和调整高度<br>2、editText获取焦点事件的拦截（也是通过ontouch实现的）  </p>
<pre><code>cn.dreamtobe.kpswitch.util.KeyboardUtil#attach(android.app.Activity, cn.dreamtobe.kpswitch.IPanelHeightTarget,    cn.dreamtobe.kpswitch.util.KeyboardUtil.OnKeyboardShowingListener)  
</code></pre><p>这里实际上是加了个  </p>
<pre><code>contentView.getViewTreeObserver().
                addOnGlobalLayoutListener(
                        new KeyboardStatusListener(isFullScreen, isTranslucentStatus,
                                isFitSystemWindows,
                                contentView, target, listener));  
</code></pre><p>在onGlobalLayout里面计算出合适的高度设置给pannelView</p>
<pre><code>userRootView.getWindowVisibleDisplayFrame(r);
            displayHeight = (r.bottom - r.top);
......              
calculateKeyboardHeight(displayHeight);
calculateKeyboardShowing(displayHeight);

中 calculateKeyboardHeight

panelHeightTarget.refreshHeight
</code></pre><p>这里涉及到一个问题就是初始时候不止到键盘高度怎么办(或者手动调整过键盘高度怎么办)<br>初始高度：会设置一个默认的最小高度给panel，然后待键盘完全弹出后在修复这个高度  </p>
<pre><code>panelLayoutHandler.resetToRecommendPanelHeight(panelHeight)
&gt;&gt;
ViewUtil.refreshHeight(panelLayout, recommendPanelHeight);
......
final int validPanelHeight = KeyboardUtil.getValidPanelHeight(view.getContext());
ViewGroup.LayoutParams layoutParams = view.getLayoutParams();
if (layoutParams == null) {
    layoutParams = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
            validPanelHeight);
    view.setLayoutParams(layoutParams);
} else {
    layoutParams.height = validPanelHeight;
    view.requestLayout();
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/android全屏模键盘冲突/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/10/android全屏模键盘冲突/" itemprop="url">
                  全屏模式底部键盘冲突
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T00:00:00+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="场景：全屏模式下activity的adjustResize-失效-弹键盘时候底部的输入框无法自动调整到键盘区域的上方"><a href="#场景：全屏模式下activity的adjustResize-失效-弹键盘时候底部的输入框无法自动调整到键盘区域的上方" class="headerlink" title="场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方"></a>场景：全屏模式下activity的adjustResize 失效,弹键盘时候底部的输入框无法自动调整到键盘区域的上方</h1><h2 id="1-方案一："><a href="#1-方案一：" class="headerlink" title="1. 方案一："></a>1. 方案一：</h2><p>使用 AndroidBug5497Workaround （<a href="https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）" target="_blank" rel="external">https://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible）</a>  </p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_normal.gif?raw=true" height="200px" width="100px">  </p>
<p>原理：通过 getViewTreeObserver().addOnGlobalLayoutListener监听当前屏幕显示区域的大小，然后动态调整Activity rootView的height，实现“adjust resize”的效果   </p>
<pre><code> Rect r = new Rect();
 mChildOfContent.getWindowVisibleDisplayFrame(r);
int usableHeightNow = r.bottom - r.top;
  if (usableHeightNow != usableHeightPrevious) {
      int usableHeightSansKeyboard = mChildOfContent.getRootView().getHeight();
      int heightDifference = usableHeightSansKeyboard - usableHeightNow;
      if (heightDifference &gt; (usableHeightSansKeyboard/4)) {
          // keyboard probably just became visible
          frameLayoutParams.height = usableHeightSansKeyboard - heightDifference;
      } else {
          // keyboard probably just became hidden
          frameLayoutParams.height = usableHeightSansKeyboard;
      }
      mChildOfContent.requestLayout();
      usableHeightPrevious = usableHeightNow;
</code></pre><p>但是这个不能完全解决我们问题，会遇到下面的问题：<br>在输入框在屏幕区域上方是没问题，在输入框在底部时候，会有一个特别不好的现象，键盘弹出后会迅速把整个Activity完全顶上去，然后调整回来。  </p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/planA.gif?raw=true" height="200px" width="100px"></p>
<p>问题的原因是是OnGlobalLayoutListener不是实时和键盘弹时屏幕显示区域同步的。所以就会在键盘弹起的瞬间先把整个activity顶上去，然后顶上去后，屏幕内容又会掉下来  </p>
<p>补丁方案：<br>输入框在底部时候不要直接弹出键盘，先让顶部的一个1px的输入框获得这个这个焦点，待键盘完全弹出来后再把焦点传递给底部的这个输入框，这样就不会有顶整个界面起来的现象</p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/planA_fix.gif?raw=true" height="200px" width="100px"></p>
<p>补充问题<br>为什么在顶部的时候不会出现顶上去又下来的情况？<br>因为 输入框在最上面，键盘输入法只要弹出时不盖住输入框，就不会顶起这个Activity的内容，而内容区域调整也是延迟于键盘弹起速度的，但是由于键盘盖住了所以视觉感觉不出来    </p>
<h2 id="2-方案二"><a href="#2-方案二" class="headerlink" title="2.方案二"></a>2.方案二</h2><p>JkeyboardSwitch （<a href="https://github.com/Jacksgong/JKeyboardPanelSwitch）" target="_blank" rel="external">https://github.com/Jacksgong/JKeyboardPanelSwitch）</a>  </p>
<p>原理是在输入框下面加了一个和键盘高度相同的panel，在键盘弹出来的瞬间panel显示出来（invisualble状态），这样键盘的弹出和隐藏与panel的的invisualble和gone的状态同步起来，看起来的效果就是键盘出来时候把输入框顶上去，键盘收起来时候把输入框收回去  </p>
<p>这个方案的一个问题是“怎么在第一次弹出时候初始化panel高度和键盘高度一致?”    </p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/planB.gif?raw=true" height="200px" width="100px"></p>
<p>补丁方案：<br>第一次弹出瞬间把输入框的区域设置为Invisualbel ，初始panel的高度尽量大，待键盘完全弹出后把输入框区域显示出来，然后调整panel的高度，这样就能在用户无察觉的情况初始化这个panel高度。   </p>
<p><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/planB_fix.gif?raw=true" height="200px" width="100px"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/03/AMS浅析_02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/03/AMS浅析_02/" itemprop="url">
                  AMS server端分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Ams-server端"><a href="#Ams-server端" class="headerlink" title="Ams  server端"></a>Ams  server端</h1><h2 id="核心类："><a href="#核心类：" class="headerlink" title="核心类："></a>核心类：</h2><p>ActivityManagerNative是从Client接受binder 消息<br>ApplicationThreadNative 是从AMS向Client发送指令<br>ActivityStackSupervisor<br>ActivityStack就是存储ActivityRecord的容器，主要操作都是通过ActivityStackSupervisor来做的</p>
<p>ps:注意接IApplicationThread   </p>
<pre><code>A. ApplicationThreadNative实现了一部分，ActivityMangerService继承ApplicationThreadNative,然后实现了剩余的    
B. ApplicationThreadNative.ApplicationThreadProxy完全实现了IApplicationThread
</code></pre><h2 id="Activity-A启动Activity-B流程"><a href="#Activity-A启动Activity-B流程" class="headerlink" title="Activity A启动Activity B流程"></a>Activity A启动Activity B流程</h2><h2 id="1-Activity-A启动Activity-B流程"><a href="#1-Activity-A启动Activity-B流程" class="headerlink" title="1. Activity A启动Activity B流程"></a>1. Activity A启动Activity B流程</h2><p>ActivityManagerNative#onTransact（）&gt;&gt;<br>ActivityManagerService#startActivity()&gt;&gt;<br>ActivityManagerService#startActivityAsUser()&gt;&gt;<br>ActivityStackSupervisor#startActivityMayWait()&gt;&gt;<br>ActivityStack#resumeTopActivityLocked（）&gt;&gt;<br>ActivityStack#startPausingLocked（）&gt;&gt;<br>pause上一个Activity的调用方法</p>
<pre><code>prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,  userLeaving, prev.configChangeFlags);
</code></pre><p>ActivityMangerNative.ApplicationThreadProxy.schedulePauseActivity  &gt;&gt;<br>）</p>
<p>等client pause完了后<br>ActivityManagerNative#activityPaused（）<br>这里实际调用的是ActivityManagerService的activityPaused（）&gt;&gt;<br>ActivityStack#completePauseLocked() &gt;&gt;<br>ActivityStack#resumeTopActivityLocked（）&gt;&gt;<br>ActivityStackSupervisor#resumeTopActivitiesLocked(topStack, prev, null);  </p>
<p>这时候有两部分，如果当前应用还没有启动就通过Process  </p>
<pre><code>    if (app != null &amp;&amp; app.thread != null) {
        try {
            app.addPackage(r.info.packageName, mService.mProcessStats);
            realStartActivityLocked(r, app, andResume, checkConfig);
            return;
        } catch (RemoteException e) {
            Slog.w(TAG, &quot;Exception when starting activity &quot;
                    + r.intent.getComponent().flattenToShortString(), e);
        }

        // If a dead object exception was thrown -- fall through to
        // restart the application.
    }

    mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
            &quot;activity&quot;, r.intent.getComponent(), false, false, true);
}
</code></pre><h3 id="1-1-在已有进程中启动"><a href="#1-1-在已有进程中启动" class="headerlink" title="1.1 在已有进程中启动"></a>1.1 在已有进程中启动</h3><p>ActivityStackSupervisor#realStartActivityLocked（）&gt;&gt;  </p>
<pre><code>app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
System.identityHashCode(r), r.info,
new Configuration(mService.mConfiguration), r.compat,
app.repProcState, r.icicle, results, newIntents, !andResume,
mService.isNextTransitionForward(), profileFile, profileFd,profileAutoStop;  
</code></pre><p>ActivityMangerNative.ApplicationThreadProxy.scheduleLaunchActivity  &gt;&gt;  </p>
<h3 id="1-2-App进程不存在，需要新建"><a href="#1-2-App进程不存在，需要新建" class="headerlink" title="1.2 App进程不存在，需要新建"></a>1.2 App进程不存在，需要新建</h3><p>ActivityManagerService#startProcessLocked()&gt;&gt;      </p>
<h4 id="1-2-1-fork一个新的进程的三个步骤："><a href="#1-2-1-fork一个新的进程的三个步骤：" class="headerlink" title="1.2.1 fork一个新的进程的三个步骤："></a>1.2.1 fork一个新的进程的三个步骤：</h4><p>①AMS通过Socket通信，向Zygote发送一个创建进程请求，Zygote创建新进程。<br>②创建好进程后，调用ActivityThread.main()。到此，我们到了新了一个进程中，也是程序的入口出。<br>③调用ActivityThread.attach()开始新的应用程序，接着同过Binder通信通知AMS，新的进程已经创建好了，可以开始新的程序了。  </p>
<h4 id="1-2-2-ActivityManagerNative-attachApplication"><a href="#1-2-2-ActivityManagerNative-attachApplication" class="headerlink" title="1.2.2  ActivityManagerNative.attachApplication()"></a>1.2.2  ActivityManagerNative.attachApplication()</h4><p>ps：实际调用的是ActivityManagerService.attachApplication<br>①根据Binder.getCallingPid(),或得客户进程pid，并调用attachApplicationLocked(IApplicationThreadthread,int pid)<br>②在attachApplicationLocked中，根据pid找到对应的ProcessRecord对象，如果找不到说明改pid客户进程是一个没经过AMS允许的进程。<br>③为ProcessRecordapp对象内部变量赋值<br>④确保目标程序（APK）文件已经被转换为了odex文件。Android中安装程序是APK文件，实际上是一个zip文件。<br>⑤调用ActivityStack.realStartActivityLocked通知客户进程运行指定Activity.<br>⑥调用ApplicationThread.scheduleLaunchActivity，启动指定Activity。  </p>
<h4 id="1-2-3-客户进程启动指定Activity"><a href="#1-2-3-客户进程启动指定Activity" class="headerlink" title="1.2.3 客户进程启动指定Activity"></a>1.2.3 客户进程启动指定Activity</h4><p>AMS通过IPC通行，通知客户进程启动指定Activity：<br>①调用ApplicationThread.scheduleLaunchActivity<br>②经过Handler消息传动，调用ActivityThread.handleLaunchActivity()<br>③调用ActivityThread.performLaunchActivity()完成Activity的加载，并最终调用Activity生命周期的onCreate()方法<br>④performLaunchActivity返回，继续调用ActivityThread.handleResumeActivity(),该方法内部又调用ActivityThread.performResumeActivity(),其内部仅仅调用了目标Activity的onResume()方法。到此Activity启动完成。<br>⑤添加一个IdleHandler对象，因为在一般情况下，该步骤执行完毕后，Activity就会进入空闲状态，所以就可以进行内存回收。  </p>
<h2 id="2-ActivityStack-、TaskRecord和ActivityRecord"><a href="#2-ActivityStack-、TaskRecord和ActivityRecord" class="headerlink" title="2. ActivityStack 、TaskRecord和ActivityRecord"></a>2. ActivityStack 、TaskRecord和ActivityRecord</h2><p>从ActivityStack#destroyActivityLocked（）&gt;&gt;     </p>
<p>ActivityStack#removeActivityFromHistoryLocked（）&gt;&gt;  </p>
<pre><code>final TaskRecord task = r.task;
if (task != null &amp;&amp; task.removeActivity(r)) {
    if (DEBUG_STACK) Slog.i(TAG,
             &quot;removeActivityFromHistoryLocked: last activity removed from &quot; + this);
     if (mStackSupervisor.isFrontStack(this) &amp;&amp; task == topTask() &amp;&amp; task.mOnTopOfHome) {
          mStackSupervisor.moveHomeToTop();
      }
       mStackSupervisor.removeTask(task);
  }
 r.takeFromHistory()
</code></pre><p>这里正式开始处理TaskRecord栈里面Activity记录</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/01/AMS浅析_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/01/AMS浅析_01/" itemprop="url">
                  AMS client端分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-01T00:00:00+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Activity启动理解"><a href="#Activity启动理解" class="headerlink" title="Activity启动理解"></a>Activity启动理解</h1><p>PS：<br>一定要下载官方对应版本SDK，然后应用的SDK版本也要对应<br>建议配合GrepCode 查找类的位置，</p>
<h1 id="1-Android的CS模式"><a href="#1-Android的CS模式" class="headerlink" title="1. Android的CS模式"></a>1. Android的CS模式</h1><p>Android启动是通过AtivityThread的main函数启动的，<br>四大组件的生命周期都是通过AMS远程控制的，比如我们启动一个Acitivity,Service等都不是直接启动的，都是binder告诉AMS我们要启动四大组件，然后AMS通过binder处理（比如Activity A要启动Activity B，但是中途涉及到A的onpause  onStop和B 的oncreate，都是AMS依据ActivityRecord进行处理的）</p>
<h1 id="2-三个核心部分"><a href="#2-三个核心部分" class="headerlink" title="2. 三个核心部分"></a>2. 三个核心部分</h1><h2 id="client端："><a href="#client端：" class="headerlink" title="client端："></a>client端：</h2><p>ActivityThread<br>ActivityMangerNative   和ActivityManagerProxy<br>ApplicationThread和ApplicationThreadNative  </p>
<p>其实还涉及到：其它的比如 Instrumentation但是这个不是核心类</p>
<h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><p>ApplicationThreadProxy<br>ActivityMangerService<br>ProcessRecord<br>ActivityStack<br>ActivityRecord  </p>
<h2 id="跨进程通讯Binder"><a href="#跨进程通讯Binder" class="headerlink" title="跨进程通讯Binder"></a>跨进程通讯Binder</h2><p>Binder 和 Parcel</p>
<h1 id="3-Activity-A-启动Activity-B的流程详解"><a href="#3-Activity-A-启动Activity-B的流程详解" class="headerlink" title="3. Activity A 启动Activity B的流程详解"></a>3. Activity A 启动Activity B的流程详解</h1><p>ps：<br>ActivityMangerNative是往AMS发送消息的<br>ApplicationThread是从AMS接受指令消息的</p>
<h2 id="1、Client发送Intent"><a href="#1、Client发送Intent" class="headerlink" title="1、Client发送Intent"></a>1、Client发送Intent</h2><p>Activity#startActivity(Intent) &gt;&gt; Instrumentation#execStartActivity()  &gt;&gt;<br>ActivityManagerNative#startActivity() &gt;&gt;</p>
<h2 id="2、AMS-查询栈，告诉要Pause"><a href="#2、AMS-查询栈，告诉要Pause" class="headerlink" title="2、AMS 查询栈，告诉要Pause"></a>2、AMS 查询栈，告诉要Pause</h2><p>ActivityMangerNative#onTransact() &gt;&gt;    </p>
<p>ActivityMangerNative#schedulePauseActivity()这里是抽象的具体实现在<br>ActivityThread$ApplicationThread#schedulePauseActivity() &gt;&gt;   </p>
<p>ActivityThread#sendMessage() 也就是通过H mH 发送Message&gt;&gt;<br>ActivityThread$H#handleMessage()&gt;&gt;<br>ActivityThread#handlePauseActivity这里先要取出当前Activity ActivityClientRecord r = mActivities.get(token) &gt;&gt;<br>ActivityThread#performPauseActivity()&gt;&gt;    </p>
<p>Instrumentation#callActivityOnPause &gt;&gt;</p>
<p> ActivityManagerNative#activityPaused(token) 这个是在上一步Instrumentation pause完Activity后顺序执行的<br> 这里也就是通过binder发送消息&gt;&gt;  </p>
<p> PS:Activity切换要不要调用onstop 要看Theme，如果是android:style/Theme.Translucent就不会调用Onstop。所以我是不讲stop这个流程（实际上鄙人是有点懒。。。）</p>
<h2 id="3、AMS正式启动-Activity-B"><a href="#3、AMS正式启动-Activity-B" class="headerlink" title="3、AMS正式启动 Activity B"></a>3、AMS正式启动 Activity B</h2><p> ActivityMangerNative#onTransact() &gt;&gt;    </p>
<p>ActivityMangerNative#scheduleLaunchActivity()这里是抽象的具体实现在<br>ActivityThread$ApplicationThread#scheduleLaunchActivity() &gt;&gt;  </p>
<p>经过H mH转到主线程里面<br>ActivityThread#handleLaunchActivity&gt;&gt; </p>
<p>ActivityThread#performLaunchActivity<br>初始化Activity包括以下几步  </p>
<ol>
<li><p>生成Activity B ，这里仅仅是生成简单的java类 </p>
<pre><code>java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
         activity = mInstrumentation.newActivity(
                 cl, component.getClassName(), r.intent);  
</code></pre></li>
<li><p>附加给Activity 各种Android系统类型</p>
<pre><code>attach(Context context, ActivityThread aThread,
    Instrumentation instr, IBinder token, int ident,
    Application application, Intent intent, ActivityInfo info,
    CharSequence title, Activity parent, String id,
    NonConfigurationInstances lastNonConfigurationInstances,
    Configuration config, String referrer, IVoiceInteractor voiceInteractor) 
</code></pre></li>
<li><p>回调oncreate  注意这个地方不会通知AMS</p>
<pre><code>mInstrumentation.callActivityOnCreate(activity, r.state);  
</code></pre></li>
</ol>
<p>最终这个会调用到Activity的oncreate</p>
<p>ps：ActivityThread.H 的Message可以看看，就可以知道有哪些操作需要和AMS打交道 </p>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<p>ActivityThread#handleResumeActivity<br>这里会依次调用</p>
<ol>
<li>ActivityThread#performResumeActivity(token, clearHide)   </li>
<li>ActivityManagerNative#willActivityBeVisible（）<br>告诉AMS Activity已经准备好了   </li>
<li>ActivityManagerNative#activityResumed（）<br>告诉AMS Activity已经resumed</li>
</ol>
<p>在2、3步骤里面就是做Activity B的界面绘制工作:</p>
<pre><code>r.window = r.activity.getWindow();
View decor = r.window.getDecorView();
decor.setVisibility(View.INVISIBLE);
ViewManager wm = a.getWindowManager();
a.mDecor = decor;
l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
l.softInputMode |= forwardBit;
if (a.mVisibleFromClient) {
    a.mWindowAdded = true;
    wm.addView(decor, l);
    }
</code></pre><p>具体流程参考ActivityThread#handleResumeActivity()流程</p>
<p>涉及到window，DecroView等</p>
<h2 id="AMS-通知显示Acitivity-B已经Onresume，"><a href="#AMS-通知显示Acitivity-B已经Onresume，" class="headerlink" title="AMS 通知显示Acitivity B已经Onresume，"></a>AMS 通知显示Acitivity B已经Onresume，</h2><p>然后就是和onpause一样的流程并且回调Activity的onResume</p>
<h1 id="4-哪些是公用的，为hook做准备"><a href="#4-哪些是公用的，为hook做准备" class="headerlink" title="4. 哪些是公用的，为hook做准备"></a>4. 哪些是公用的，为hook做准备</h1>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/01/分析UI流畅度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/01/分析UI流畅度/" itemprop="url">
                  Android 性能检测
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T00:00:00+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="手机端："><a href="#手机端：" class="headerlink" title="手机端："></a>手机端：</h1><h2 id="开发者选项"><a href="#开发者选项" class="headerlink" title="开发者选项"></a>开发者选项</h2><ol>
<li><p>绘图》 显示布局边界</p>
</li>
<li><p>硬件加速渲染 》调试GPU过渡绘制  要打开</p>
</li>
</ol>
<ol>
<li><p>监控》启用严格模式</p>
</li>
<li><p>GPU呈现模式分析  可以对照颜色表找出耗时出在那一部分<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/GPU%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F.jpg?raw=true" alt="image"></p>
</li>
</ol>
<h1 id="电脑端："><a href="#电脑端：" class="headerlink" title="电脑端："></a>电脑端：</h1><ol>
<li><p>查看MemoryMonitor  ，查看页面内存波动（对于listview ）</p>
</li>
<li><p>tools》android》android  device  monistor<br>（其实它就是把android sdk中tools下面的很多功能聚合起来；  如ddms，uiautomatorviewer，monitor等功能聚合起来，但是好像没有集成hierarchyviewer的功能）</p>
</li>
<li><p>查看录制页面变化时候的cpu耗时<br>开始录制》选中进程，点击红色方框左边的按钮，然后点击红色方框里右侧的按钮录制正式开始，需要结束时，再点击右侧按钮结束，就会有结果自动生成<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6.png?raw=true" alt="image"></p>
<p>分析结果》录制实际上是一个采样的过程，可以看图中红色方框里面最耗时的几个方法，基本上可以定位到程序的问题<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%88%86%E6%9E%90%E8%80%97%E6%97%B6_2.png?raw=true" alt="image"></p>
</li>
<li>查看布局层次，以及每一层的绘制时间，目的是减小层次<br>入口是在：tools 下面 hierarchyviewer  查看每个层次的绘制时间（这个好像必须在模拟器上看）</li>
</ol>
<h1 id="分析卡的原因"><a href="#分析卡的原因" class="headerlink" title="分析卡的原因"></a>分析卡的原因</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/krislight1105/p/5352500.html" target="_blank" rel="external">http://www.cnblogs.com/krislight1105/p/5352500.html</a><br><a href="http://blog.csdn.net/wangbaochu/article/details/50396512" target="_blank" rel="external">http://blog.csdn.net/wangbaochu/article/details/50396512</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/01/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/数据库/" itemprop="url">
                  数据库踩坑和调试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T00:00:00+08:00">
                2017-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="Android数据库设计"><a href="#Android数据库设计" class="headerlink" title="Android数据库设计"></a>Android数据库设计</h2><ol>
<li>冗余字段设计，表设计要空出2到3个冗余字段  </li>
<li>不要过多的关联查询，外键约束不要多了  </li>
<li>设计要优先考虑易用性 ，容易升级，性能方面主要要通过应用层来掌控  </li>
<li>适当的分库可以有效避免数据库被锁住。（sqlite的文件锁） </li>
</ol>
<h2 id="Android-DB操作技巧"><a href="#Android-DB操作技巧" class="headerlink" title="Android DB操作技巧"></a>Android DB操作技巧</h2><ol>
<li>对于经常要使用的DB不需要关闭，一般全局保存一个静态的SQLiteDatabase（Writable的），而且是在Application oncreate 就初始化好.  </li>
<li>由于Application  没有destroy的回调，这里我们一般会做一个ActivityStack，然后在Activity初始化和destory 时候入栈和出栈来控制界面的显示逻辑,当检测到栈为空的时候就可以认为要退出应用了。</li>
<li>能一次取完数据，不要分次取（虽然可能取得数据量有一定优化，但是分次太耗时，尽量交给上层做）</li>
<li>DataBase is locked，导致数据取不出来。 解决方向有以下几点：<br>第1点：在获取databse时候加一个锁<br>第2点：分库，对于相互关联若的数据进行分库处理<br>第3点：数据库不要关闭,并且尝试分开存writeable 和 readable两个静态的DB    <h2 id="数据库调试"><a href="#数据库调试" class="headerlink" title="数据库调试"></a>数据库调试</h2><h3 id="第一步通过AS自带的Android-monitor-把数据库导出来"><a href="#第一步通过AS自带的Android-monitor-把数据库导出来" class="headerlink" title="第一步通过AS自带的Android monitor  把数据库导出来"></a>第一步通过AS自带的Android monitor  把数据库导出来</h3><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9501.png?raw=true" alt="see"><h3 id="第二步通过Sqlite-professional"><a href="#第二步通过Sqlite-professional" class="headerlink" title="第二步通过Sqlite professional"></a>第二步通过Sqlite professional</h3>查看数据库的结构可以具体查看到每一张表的详细信息<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E8%AF%9502.png?raw=true" alt="see"><br>也可以通过query工具栏，执行基本的命令行操作。</li>
</ol>
<p>Sqlite基本命令：<a href="http://www.runoob.com/sqlite/sqlite-trigger.html" target="_blank" rel="external">http://www.runoob.com/sqlite/sqlite-trigger.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/10/图片不同尺寸缓存的优化方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/10/图片不同尺寸缓存的优化方案/" itemprop="url">
                  又拍云图片显示优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-10T00:00:00+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-又拍云的图片尺寸问题"><a href="#1-又拍云的图片尺寸问题" class="headerlink" title="1. 又拍云的图片尺寸问题"></a>1. 又拍云的图片尺寸问题</h2><p>又拍云会对我们上传的图片进行处理。然后会生成多种尺寸：110,160,210,240,320,480,640,720,1200。<br>每种尺寸对应于不同的url。<br>eg：<br><a href="http://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg" target="_blank" rel="external">http://img2048.static.suishenyun.net/d62bb1e1bf1e2c6b8fb0dd004a952a01/4414fc28822e3643ff90a7e68305e12a.jpg!w480.jpg</a></p>
<h2 id="2-简单的解决方案"><a href="#2-简单的解决方案" class="headerlink" title="2. 简单的解决方案"></a>2. 简单的解决方案</h2><p>为了利用又拍云自动帮我们处理出来的不同尺寸图片。在每次加载图片的时候根据当前显示View的尺寸加载合适的尺寸</p>
<h3 id="2-1-这里有三个没解决的问题："><a href="#2-1-这里有三个没解决的问题：" class="headerlink" title="2.1 这里有三个没解决的问题："></a>2.1 这里有三个没解决的问题：</h3><ol>
<li><p>不同尺寸的图片会在sd卡上存不同cache，比如由于我们先加载了640尺寸的图片，后面加载480尺寸还是无法公用640尺寸的图片cache,导致还得重新请求一次网络。实际上我们可以通过处理得到480尺寸的图片。</p>
</li>
<li><p>对于发带图片帖子的这种逻辑处理逻辑处理不方便。因为上传图片后，很有可能不知道图片的显示尺寸。无法把这张本地图片放置到对应位置的cache上去（虽然我们现在上传上去后，会直接显示的是本地图片，但这个有点治标不治本。第二次进来时候或者下拉刷新后 还是会从网上load这张图片）。</p>
</li>
<li><p>图片尺寸的获取，不是所有的ImageView在setImageUrl时候都可以获取尺寸，有的量不到尺寸，也就是在一个还没有渲染 并且也没有设置固定size的ImageVIew上设置Url（比Adapter里面的初次createView  然后立即设置Url就会出现量不到尺寸的问题）</p>
</li>
</ol>
<p>总结一些：又拍云会帮我们处理出来不同尺寸的图片。在小的地方我们可以仅仅加载小尺寸的图片，提高了展示速度。但是对于同一张图片，在不同地方展示不同尺寸的逻辑处理不够完美。所以以前在wecal里面会发现一个问题：同一个头像，已经展示过了，在下一个页面里用另个尺寸展示的时候还是会有点慢。 </p>
<h2 id="3-对于又拍云的图片完美解决方案"><a href="#3-对于又拍云的图片完美解决方案" class="headerlink" title="3. 对于又拍云的图片完美解决方案"></a>3. 对于又拍云的图片完美解决方案</h2><p>核心需要在内存和sd卡缓存逻辑能够识别出不同尺寸的不同图片。也就是要每一url对应于一组cache。</p>
<p>代码实现上就是要把当前的url的cache对应到一组cache 上去。<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD01.png?raw=true" alt=""></p>
<h3 id="3-1-Memery-cache逻辑"><a href="#3-1-Memery-cache逻辑" class="headerlink" title="3.1 Memery cache逻辑"></a>3.1 Memery cache逻辑</h3><p>对于内存cache 建议还是按照以前的逻辑走，但是可以加上对于一个尺寸的的图片可以使用相近已经缓存尺寸的图片。</p>
<h3 id="3-2-Disk-cache逻辑"><a href="#3-2-Disk-cache逻辑" class="headerlink" title="3.2 Disk cache逻辑"></a>3.2 Disk cache逻辑</h3><p>对于Disk cache 。如果需要加载一个小尺寸的图片，但是发现只有大尺寸图片，我们可以直接使用大图压缩出小图，返回过去。<br><img src="https://github.com/liuyicheng3/learning-summary/blob/master/images/%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD02.png?raw=true" alt=""></p>
<h3 id="3-3-2G网络模式"><a href="#3-3-2G网络模式" class="headerlink" title="3.3 2G网络模式"></a>3.3 2G网络模式</h3><p>在低速网络情况下，对于disk cache，如果发现没有当前尺寸的图片的情况下，可以使用任意尺寸的缓存转化。</p>
<h2 id="5-推荐一个图片压缩库"><a href="#5-推荐一个图片压缩库" class="headerlink" title="5. 推荐一个图片压缩库"></a>5. 推荐一个图片压缩库</h2><p>Luban：<a href="https://github.com/Curzibn/Luban" target="_blank" rel="external">https://github.com/Curzibn/Luban</a>      大小仅仅是15K</p>
<p>根据我的测试一般可以在不明显影响图片展示效果的条件减少图片体积2/3。使用它后发图片备注速度飞快。（在wecal里面默认发送压缩后的图片，也提供发送原图的可选项）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/01/Okhttp核心流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/01/Okhttp核心流程/" itemprop="url">
                  Okhttp核心流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-01T20:10:33+08:00">
                2016-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Interface：OkhttpClient（singleton）-Request-Response"><a href="#Interface：OkhttpClient（singleton）-Request-Response" class="headerlink" title="Interface：OkhttpClient（singleton）  Request  Response"></a>Interface：OkhttpClient（singleton）  Request  Response</h2><h2 id="主要由以下三部分-组成"><a href="#主要由以下三部分-组成" class="headerlink" title="主要由以下三部分 组成"></a>主要由以下三部分 组成</h2><h3 id="1-任务调度：-核心类disruptor（singleton）"><a href="#1-任务调度：-核心类disruptor（singleton）" class="headerlink" title="1. 任务调度： 核心类disruptor（singleton）"></a>1. 任务调度： 核心类disruptor（singleton）</h3><p>a. 线程池<br>b. 队列</p>
<pre><code>/** Ready async calls in the order they&apos;ll be run. */
private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();

/** Running asynchronous calls. Includes canceled calls that haven&apos;t finished yet. */
private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();

/** Running synchronous calls. Includes canceled calls that haven&apos;t finished yet. */
 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;();
</code></pre><p>(由于okhttp两种 运行模式   sync  和async）</p>
<h3 id="2-网络请求"><a href="#2-网络请求" class="headerlink" title="2. 网络请求"></a>2. 网络请求</h3><ul>
<li>核心类RealCall HttpEngine StreamAllocation   Interceptor (及其中的内部类  Chain） </li>
<li>每个请求会生成一个Request  </li>
<li>然后根据 request  和httpclieant  生成唯一的 RealCall(在real里面会构造出一个httpengine)  </li>
</ul>
<p>okhttp一个请求的完整流程图<br> <img src="http://blog.piasy.com/img/201607/okhttp_full_process.png" alt="image"></p>
<p>在realcall的execute方法中会调用     </p>
<pre><code>client.dispatcher().executed(this);//问题1  
Response result = getResponseWithInterceptorChain(false);//问题2  
</code></pre><p>获得请求结果.<br>现在看问题1  在这里面干了写什么<br>其实就是 dispatcher记录任务而已 ，没有任何执行方法<br>核心在问题2中<br>她会  </p>
<pre><code>Interceptor.Chain chain = new ApplicationInterceptorChain(0, originalRequest, forWebSocket);
return chain.proceed(originalRequest);
</code></pre><p>也就是生成拦截器 ，并用这个拦截器启动这个请求<br>继续进入proceed 可以看到<br>进入了ApplicationInterceptorChain的getresponse方法<br>开始构造HttpEngine    </p>
<pre><code>engine.sendRequest();//问题21
engine.readResponse();//问题22
</code></pre><p>在问题21中其实就是  Rfc 标准的一种 实现  </p>
<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);
Response cacheCandidate = responseCache != null
    ? responseCache.get(request)
    : null;
</code></pre><p>就是看当前是否配置了cache   如果有cache   则在responseCache.get找 当前request的cache<br>这个过程 就是根据 Util.md5Hex(request.url().toString())的从map中取值cacheCandidate的过程<br>当取到值后还要根据http cache的rfc标准  判断  是否合理能使用<br>new CacheStrategy.Factory(now, request, cacheCandidate).get();<br>在CacheStrategy中 这里会真正的判断和并处理当前的reponse cache和request（处理request是为了  当cache过期后还可以通过304  机制实现重用）；  </p>
<p>这里需要判断  当前的  cacheCOntrol    Expires等  （尤其要处理一种情况就是当cache过期了  要根据 etag和Last-Modified  等等  要在request 中添加参数）</p>
<pre><code>if (etag != null) {
  conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);
} else if (lastModified != null) {
  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);
} else if (servedDate != null) {
  conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);
}

Request conditionalRequest = conditionalRequestBuilder.build();
</code></pre><p>这是请求前的工作<br>现在开始发送请求</p>
<pre><code>httpStream = connect();
httpStream.setHttpEngine(this);
</code></pre><p>这一部分的核心是StreamAllaction（辅助是ConnectionPool 和Route  RouteSelector）</p>
<pre><code>streamAllocation.newStream(client.connectTimeoutMillis(),
client.readTimeoutMillis(), client.writeTimeoutMillis(),
client.retryOnConnectionFailure(), doExtensiveHealthChecks);
</code></pre><p>解决的问题 是socket连接重用和  route<br>先是从连接池中找</p>
<pre><code>// Attempt to get a connection from the pool.
 RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this);
 if (pooledConnection != null) {
   this.connection = pooledConnection;
   return pooledConnection;
 }
</code></pre><p>如果没有的话就看route可以重用嘛</p>
<pre><code> if (selectedRoute == null) {
  selectedRoute = routeSelector.next();
  synchronized (connectionPool) {
    route = selectedRoute;
  }
}
RealConnection newConnection = new RealConnection(selectedRoute);
acquire(newConnection);
</code></pre><p>（这其实和一个dns解析 有关系也就是 一个域名对应多个ip  而且不一定所有的ip都是通的  建立连接的时候会尝试 所有的  直到通了为止</p>
<pre><code>RouteDatabase里的Set&lt;Route&gt; failedRoutes = new LinkedHashSet&lt;&gt;()）
</code></pre><p>弄完之后就是放如   </p>
<pre><code>Internal.instance.put(connectionPool, newConnection);
</code></pre><p>连接池中  方便下次继续使用<br>下一步 就是建立socket连接的过程</p>
<pre><code> newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),
    connectionRetryEnabled);
routeDatabase().connected(newConnection.route());
</code></pre><p>跟进去 就是</p>
<pre><code>connectSocket(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector);
</code></pre><p>继续</p>
<pre><code> try {
  Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
} catch (ConnectException e) {
  throw new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());
}
source = Okio.buffer(Okio.source(rawSocket));
sink = Okio.buffer(Okio.sink(rawSocket));
</code></pre><p>连接socket（返回连接 是以Http1xStream Http2xStream）形式返回回来的<br>然后才是真正发送这个请求的过程</p>
<pre><code>httpStream.writeRequestHeaders(networkRequest);
requestBodyOut = httpStream.createRequestBody(networkRequest, contentLength);
</code></pre><p>继续跟进</p>
<pre><code> httpEngine.writingRequestHeaders();
  String requestLine = RequestLine.get(
    request, httpEngine.getConnection().route().proxy().type());
writeRequest(request.headers(), requestLine);
</code></pre><p>》》</p>
<pre><code>** Returns bytes of a request header for sending on an HTTP transport. */
public void writeRequest(Headers headers, String requestLine) throws IOException {
if (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state);
sink.writeUtf8(requestLine).writeUtf8(&quot;\r\n&quot;);
for (int i = 0, size = headers.size(); i &lt; size; i++) {
  sink.writeUtf8(headers.name(i))
      .writeUtf8(&quot;: &quot;)
      .writeUtf8(headers.value(i))
      .writeUtf8(&quot;\r\n&quot;);
}
sink.writeUtf8(&quot;\r\n&quot;);
state = STATE_OPEN_REQUEST_BODY;
}
</code></pre><p>读过程<br>就是通过这个stream构造出 newChunkedSink 或者newFixedLengthSink</p>
<p>到此 请求reponse的工作做完了<br>现在 如果是需要真正发送网络请求就也就是问题22</p>
<pre><code>networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);
</code></pre><p>》》</p>
<pre><code>engin.readResponse
</code></pre><p>》》</p>
<pre><code>// Write the request body to the socket.
if (requestBodyOut != null) {
  if (bufferedRequestBody != null) {
    // This also closes the wrapped requestBodyOut.
    bufferedRequestBody.close();
  } else {
    requestBodyOut.close();
  }
  if (requestBodyOut instanceof RetryableSink) {
    httpStream.writeRequestBody((RetryableSink) requestBodyOut);
  }
}

networkResponse = readNetworkResponse();
</code></pre><p>》》</p>
<pre><code>Response readNetworkResponse() throws IOException {
httpStream.finishRequest();

Response networkResponse = httpStream.readResponseHeaders()
    .request(networkRequest)
    .handshake(streamAllocation.connection().handshake())
    .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
    .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
    .build();

if (!forWebSocket) {
  networkResponse = networkResponse.newBuilder()
      .body(httpStream.openResponseBody(networkResponse))
      .build();
}

if (&quot;close&quot;.equalsIgnoreCase(networkResponse.request().header(&quot;Connection&quot;))
    || &quot;close&quot;.equalsIgnoreCase(networkResponse.header(&quot;Connection&quot;))) {
  streamAllocation.noNewStreams();
}

return networkResponse;
</code></pre><p>  }</p>
<p>解析和返回</p>
<pre><code> Response response = engine.getResponse();


//tobe continue（已经 cache过程 请求重试过程）
 Request followUp = engine.followUpRequest();
</code></pre><h3 id="3-cache管理"><a href="#3-cache管理" class="headerlink" title="3. cache管理"></a>3. cache管理</h3><p>最后附上 相关的http请求cache的rfc内容<br> <img src="https://raw.githubusercontent.com/liuyicheng3/learning-summary/master/images/http_cache.jpg" alt="image"></p>
<h3 id="每个状态的详细说明如下："><a href="#每个状态的详细说明如下：" class="headerlink" title="每个状态的详细说明如下："></a>每个状态的详细说明如下：</h3><h4 id="1-Last-Modified"><a href="#1-Last-Modified" class="headerlink" title="1. Last-Modified"></a>1. Last-Modified</h4><p>在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(HttpReponse Header)此文件在服务期端最后被修改的时间，格式类似这样：<br>Last-Modified:Tue, 24 Feb 2009 08:01:04 GMT<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头(HttpRequest Header)，询问该时间之后文件是否有被修改过：<br>If-Modified-Since:Tue, 24 Feb 2009 08:01:04 GMT<br>如果服务器端的资源没有变化，则自动返回HTTP304（NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。<br>注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求  </p>
<h4 id="2-Etag工作原理"><a href="#2-Etag工作原理" class="headerlink" title="2. Etag工作原理"></a>2. Etag工作原理</h4><p>HTTP协议规格说明定义ETag为“被请求变量的实体标记”（参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：<br>Etag:“5d8c72a5edda8d6a:3239″<br>客户端的查询更新格式是这样的：<br>If-None-Match:“5d8c72a5edda8d6a:3239″<br>如果ETag没改变，则返回状态304。<br>即:在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″<br>标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个If-None-Match报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。<br>If-None-Match:“5d8c72a5edda8d6a:3239“<br>,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304(Not Modified) Response。  </p>
<h4 id="3-Expires"><a href="#3-Expires" class="headerlink" title="3. Expires"></a>3. Expires</h4><p>给出的日期/时间后，被响应认为是过时。如Expires:Thu, 02 Apr 2009 05:14:08 GMT<br>需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端.当缓存中数据失效或过期，才决定从服务器更新数据。  </p>
<h4 id="4-Last-Modified和Expires"><a href="#4-Last-Modified和Expires" class="headerlink" title="4. Last-Modified和Expires"></a>4. Last-Modified和Expires</h4><p>Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而且要和Expires一起用。  </p>
<h4 id="5-Etag和Expires"><a href="#5-Etag和Expires" class="headerlink" title="5. Etag和Expires"></a>5. Etag和Expires</h4><p>如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.  </p>
<h4 id="6-Last-Modified和Etag"><a href="#6-Last-Modified和Etag" class="headerlink" title="6. Last-Modified和Etag"></a>6. Last-Modified和Etag</h4><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)<br>Last-Modified和ETags请求的http报头一起使用，服务器首先产生Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存<br>过程如下:  </p>
<ul>
<li>客户端请求一个页面（A）。  </li>
<li>服务器返回页面A，并在给A加上一个Last-Modified/ETag。  </li>
<li>客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。  </li>
<li>客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。  </li>
<li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。  </li>
</ul>
<p>备注：   </p>
<ul>
<li>Last-Modified和Etag头都是由WebServer发出的HttpReponse Header，WebServer应该同时支持这两种头。  </li>
<li>WebServer发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；  </li>
<li>客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的HttpRequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的Last-Modified,Etag值完全一样；  </li>
<li>通过上述值到服务器端检查，判断文件是否继续缓存；  </li>
</ul>
<h4 id="7-关于-Cache-Control-max-age-秒-和-Expires"><a href="#7-关于-Cache-Control-max-age-秒-和-Expires" class="headerlink" title="7.关于 Cache-Control: max-age=秒 和 Expires"></a>7.关于 Cache-Control: max-age=秒 和 Expires</h4><p>Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）<br>max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。<br>如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。<br>Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。<br>Expires =max-age +   “每次下载时的当前的request时间”<br>所以一旦重新下载的页面后，expires就重新计算一次，但last-modified不会变化   </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/01/沉浸式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/01/沉浸式/" itemprop="url">
                  沉浸式的实现方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-01T08:00:00+08:00">
                2016-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Step-1："><a href="#Step-1：" class="headerlink" title="Step 1："></a>Step 1：</h1><p>把状态栏设置为透明</p>
<pre><code>    if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.LOLLIPOP&amp;&amp;!Build.BRAND.equalsIgnoreCase(&quot;huawei&quot;)){/**5.0及以上且不是华为,
            因为华为5.0以上系统已经全屏但是状态栏黑色改不掉*/
        Window window = getWindow();
        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS
                | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
        window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
                | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
        if(Build.VERSION.SDK_INT&gt;= Build.VERSION_CODES.M){
            window.setStatusBarColor(Color.TRANSPARENT);
            if(Build.MANUFACTURER.toLowerCase().contains(&quot;xiaomi&quot;)) {
                setMiuiStatusBarDarkMode(true);
            }
        }else{
            window.setStatusBarColor(Color.argb(0x80,0x00,0x00,0x00));
        }

    }else{/**5.0以下，4.0及以上*/
        Window win = getWindow();
        WindowManager.LayoutParams winParams = win.getAttributes();
        int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
        winParams.flags |= bits;
        win.setAttributes(winParams);
    }
    /**由于MIUI 6修改过所以系统方法无法设置状态栏字体颜色无效，需要使用该方法设置
    *ps:mui上设置状态栏字体颜色为深色
    *
    */
    public void setMiuiStatusBarDarkMode(boolean isdarkmode) {
    Class&lt;? extends Window&gt; clazz = this.getWindow().getClass();
    try {
        int darkModeFlag = 0;
        Class&lt;?&gt; layoutParams = Class.forName(&quot;android.view.MiuiWindowManager$LayoutParams&quot;);
        Field field = layoutParams.getField(&quot;EXTRA_FLAG_STATUS_BAR_DARK_MODE&quot;);
        darkModeFlag = field.getInt(layoutParams);
        Method extraFlagField = clazz.getMethod(&quot;setExtraFlags&quot;, int.class, int.class);
        extraFlagField.invoke(this.getWindow(), isdarkmode ? darkModeFlag : 0, darkModeFlag);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h2 id="Step-2："><a href="#Step-2：" class="headerlink" title="Step 2："></a>Step 2：</h2><p>设置绘制区域</p>
<pre><code>rootView.setFitsSystemWindows(true);
rootView.setClipToPadding(true);
</code></pre><p>这样rootView就顶上头部去了，但是有个副作用就是界面显示区域也扩展下面的虚拟按键后面了，所以要对于alignparentbottom的功能栏，就不能直接放到rootView里面，必须放到与rootView外面。这样功能栏就不会被底部的虚拟按键盖住（这里不要考虑计算虚拟按键的高度，已经是否有虚拟按键，华为手机可以通过手势动态展开或者收起虚拟按键）</p>
<h2 id="注意机型："><a href="#注意机型：" class="headerlink" title="注意机型："></a>注意机型：</h2><ol>
<li>nexus固定死的虚拟按键</li>
<li>华为和小米Mix可以使用手势控制的虚拟按键</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/01/deep_link设计方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liuycheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nico随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/01/deep_link设计方案/" itemprop="url">
                  Deeplink 设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-11-01T20:10:33+08:00">
                2015-11-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>deeplink指的是在第三方客户端/浏览器中，打开一个APP的H5页面时候，如果发现本地安装了这个APP，就会使用本地APP打开。<br>需要前端和客户端互相配合来实现本功能。</p>
<h1 id="服务器端："><a href="#服务器端：" class="headerlink" title="服务器端："></a>服务器端：</h1><pre><code>&lt;html&gt;
&lt;head&gt;
&lt;meta property=&quot;al:ios:url&quot; content=&quot;applinks://docs&quot; /&gt;
&lt;meta property=&quot;al:ios:app_store_id&quot; content=&quot;12345&quot; /&gt;
&lt;meta property=&quot;al:ios:app_name&quot; content=&quot;App Links&quot; /&gt;
&lt;meta property=&quot;al:android:url&quot; content=&quot;applinks://docs&quot; /&gt;
&lt;meta property=&quot;al:android:app_name&quot; content=&quot;App Links&quot; /&gt;
&lt;meta property=&quot;al:android:package&quot; content=&quot;org.applinks&quot; /&gt;
&lt;meta property=&quot;al:web:url&quot;
content=&quot;http://applinks.org/documentation&quot; /&gt;
&lt;/head&gt;
&lt;body&gt;
Hello, world!
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>客户端deeplink的实现需要依靠jump系统。ps:jump系统可以通过URI 实现在app中的定向跳转 ，比如我们的app叫“天上人间”（缩写tsrj）。 </p>
<ol>
<li>需要先在menifest中注册相应的scheme的filter。<br>ps:一般加载主页上面.</li>
</ol>
<pre><code>&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;
&lt;!-- Accepts URIs that begin with &quot;tsrj://&quot; --&gt;
&lt;data android:scheme=&quot;tsrj&quot;/&gt;
&lt;/intent-filter&gt;
&lt;intent-filter&gt;
&lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
&lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;
&lt;!-- Accepts URIs that begin with &quot;http://m.tsrj.com/&quot; --&gt;
&lt;data
android:host=&quot;m.tsrj.com&quot;
android:pathPrefix=&quot;/&quot;
android:scheme=&quot;http&quot;/&gt;
&lt;data
android:host=&quot;m.tsrj.com&quot;
android:pathPrefix=&quot;/&quot;
android:scheme=&quot;https&quot;/&gt;
&lt;/intent-filter&gt;
</code></pre><ol>
<li>在MainActivity新增解析jump信息的方法</li>
</ol>
<pre><code>private void jump(Intent intent) {
/** 根据传过来的参数 进行jump跳转 **/
String action_url = intent.getDataString();
MLog.i(&quot;启动Main_action_url:&quot; + action_url);
if (!TextUtils.isEmpty(action_url)) {
JumpManager.jump(this, action_url);
} 
}

JumpManger就实现解析数据然后根据URI跳转的功能
public static boolean jump(Context ctx, String action_url) {

if (TextUtils.isEmpty(action_url)) {
return false;
}

MLog.d(&quot;JumpManager  url:&quot; + action_url);

Uri uri = null;

/**如果不是一个标准的uri格式说明传入的数据无效的 可以直接忽视*/

try {
uri = Uri.parse(action_url);
} catch (Exception e) {
return false;
}

if (uri == null) {
return false;
}

/**检测到是一个合法的uri 先判断是否是满足跳转需求的头部 如果是 开始进行跳转检测 如果不是 直接往内置浏览器跳*/

if (!action_url.startsWith(JumpUriFactory.JUM_URL_HEAD) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_S) &amp;&amp; !action_url.startsWith(JumpUriFactory.JUMP_URL_HEAD_CUSTOM)) {

return false;
}

Intent jumpintent = null;

List&lt;String&gt; paths = uri.getPathSegments();

/**只有头没有页面参数就返回*/
if (paths == null || paths.size() &lt;= 0) {

return false;
}

/**有path 但是path里面为空值 直接打开*/
String action = paths.get(0);
if (TextUtils.isEmpty(action)) {
if (!isFromWebView) {
jumpToInteriorPageActivity(ctx, uri);
}
return false;
}

/** 使用系统浏览器打开 */
if (action.equals(&quot;web_system&quot;)) {
jumpToSystemWebPage(ctx, uri);
return true;
}


/*else if (action.equals(JumpPageSet.detail)) {
goWaitress(ctx, action_url);
return true;
}*/

/** city */
else if (action.equals(JumpPageSet.city)) {
goCity(ctx, action_url);
return true;
}

/** usercenter */
else if (action.equals(JumpPageSet.personal_info)) {
goUserCenter(ctx, action_url);
return true;
}
</code></pre><ol>
<li>处理uri解析出里面的参数,放入intent，并跳往相应的主页</li>
</ol>
<pre><code>/**
 * 将url的数据进行解析 得到一个存放所有参数的集合
 */
public static Set&lt;String&gt; getMyQueryParameterNames(Uri uri) {
    String query = uri.getEncodedQuery();
    if (query == null) {
        return Collections.emptySet();
    }
    Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;();
    int start = 0;
    do {
        int next = query.indexOf(&apos;&amp;&apos;, start);
        int end = (next == -1) ? query.length() : next;
        int separator = query.indexOf(&apos;=&apos;, start);
        if (separator &gt; end || separator == -1) {
            separator = end;
        }
        String name = query.substring(start, separator);
        names.add(Uri.decode(name));
        // Move start to end of name.
        start = end + 1;
    } while (start &lt; query.length());
    return Collections.unmodifiableSet(names);
}
private static void goWaitress(final Context ctx, String actionUrl) {
    MLog.i(&quot;actionUrl&quot;+actionUrl);
    Uri  uri;
    uri=Uri.parse(actionUrl);
    Set&lt;String&gt;  parameters=JumpManager.getMyQueryParameterNames(uri);
    Hashtable&lt;String,String&gt; params=new Hashtable&lt;&gt;();
    if(parameters!=null&amp;&amp;parameters.size()&gt;0){
        for(String key:parameters){
            String value=uri.getQueryParameter(key);
            if(!TextUtils.isEmpty(value)){
                params.put(key,value);
            }
        }
    }
    Intent it= new Intent(act, WaitressPage.class);
    Set&lt;String&gt;  keySet=params.keySet();
    for (String k:keySet){
        it.putExtra(k,params.get(k));
    }
    startActivity(it);
    }
</code></pre><h1 id="DeepLink的坑："><a href="#DeepLink的坑：" class="headerlink" title="DeepLink的坑："></a>DeepLink的坑：</h1><ol>
<li>由于有些页面有权限限制，所以要跳页面时候，要判断在当前账户当前版本是否可以打开</li>
<li>如果从H5页面带过来的信息带有登录状态，而且当前app的账号信息和H5页面的不一致，可能需要一个账号切换工作</li>
</ol>
<p>#微信里面的deeplink：<br>微信里面的主要就是二维码加上linkme，linkme和微信有合作可以直接把分享的内容通过里面的二维码倒回到app，不过这里要注意一个问题<br>微信里面的图片对size 是有要求的</p>
<p>图片size越大被压的越厉害，，这个即使通过以下方式绕过微信sdk也无法避免被压缩</p>
<pre><code>try {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setAction(Intent.ACTION_VIEW);
    intent.addCategory(Intent.CATEGORY_DEFAULT);
    ComponentName cmp = new ComponentName(&quot;com.tencent.mm&quot;, &quot;com.tencent.mm.ui.tools.ShareScreenImgUI&quot;);
    intent.setComponent(cmp);
    String path = localImgPath;
    if (!TextUtils.isEmpty(path) &amp;&amp; !path.startsWith(&quot;file://&quot;)) {
        path = &quot;file://&quot; + path;
    }
    intent.setDataAndType(Uri.parse(path), &quot;image/jpeg&quot;);
    act.startActivity(intent);
} catch (Exception e) {
    ELog.e(&quot;wechat share failed&quot;);
}
</code></pre><p> 所以只有自己先压缩图片到一定的size，  再在这张压缩过的图片上绘制真正的二维码才行，（如果遇到好心的UI把二维码设计的很大就，可以跳过这个坑）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://github.com/liuyicheng3/learning-summary/blob/master/images/avatar.jpg?raw=true"
               alt="Liuycheng" />
          <p class="site-author-name" itemprop="name">Liuycheng</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liuycheng</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
